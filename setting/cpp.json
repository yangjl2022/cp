{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "newfile": {
        "prefix": "#newfileCPP文件模板",
        "description": "用于算法竞赛中创建C++初始代码",
        "body": [
            "/**",
            " *    author:  yangjl",
            " *    created: $CURRENT_YEAR.$CURRENT_MONTH.$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            "**/",
            "#include <bits/stdc++.h>",
            "#ifdef YJL",
            "#include \"debug.h\"",
            "#else",
            "#define debug(...)0",
            "#endif",
            "using namespace std;",
            "using ll = long long;",
            "",
            "template<class T>",
            "istream& operator>>(istream& is, vector<T>& v) {",
            "    for(auto& x : v) {",
            "        is >> x;",
            "    }",
            "    return is;",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    $0",
            "    return 0;",
            "}",
            "/*",
            "",
            "",
            "*/",
        ]
    },
    "for1": {
        "prefix": "#for1",
        "body": [
            "for(int ${1:i}=${2:1}; ${1:i}<=${3:n}; ++${1:i}) $0",
        ],
    },
    "fors_edge": {
        "prefix": "#fors_edge",
        "description": "图的遍历",
        "body": [
            "for(int ${1:i}=head[u]; ~${1:i}; ${1:i}=edge[${1:i}].next) {",
            "    int v=edge[${1:i}].t;",
            "    auto w=edge[${1:i}].l;",
            "    $0",
            "}"
        ],
    },
    "segtree线段树(Tag,Data)": {
        "prefix": "#segtree线段树(Tag,Data)",
        "body": [
            "struct Tag {",
            "    ${1:ll a,b;}",
            "    void init() {",
            "        a=1,b=0;",
            "    }",
            "    void unite(const Tag &val) {",
            "        a=a*val.a, b=b*val.a+val.b;",
            "    }",
            "};",
            "struct Data {",
            "    ll x,x2;",
            "    // init(l,args...)",
            "    template<class T>",
            "    void init(int i,const T& a) {",
            "        x=a[i],x2=1ll*a[i]*a[i];",
            "    }",
            "    void add(const Tag &val,int l,int r) {",
            "        if(val.a!=1||val.b!=0) {",
            "            x2=val.a*val.a*x2+2*val.a*val.b*x+(r-l+1)*val.b*val.b;",
            "            x=val.a*x+(r-l+1)*val.b;",
            "        }",
            "    }",
            "    friend Data operator+(const Data &lhs,const Data & rhs) {",
            "        Data re;",
            "        re.x=lhs.x+rhs.x;",
            "        re.x2=lhs.x2+rhs.x2;",
            "        return re;",
            "    }",
            "};",
            "struct Segtree {",
            "    #define u1 (u<<1)",
            "    #define u2 (u<<1|1)",
            "    vector<Data> tr;",
            "    vector<Tag> lz;",
            "    int Lpoint,Rpoint;",
            "    template<class ...T>",
            "    Segtree(int L,int R,const T&...args):Lpoint(L),Rpoint(R)",
            "    ,tr(4<<__lg(R-L+1)),lz(tr.size()) {// a[L~R]建树",
            "        build(1,L,R,args...);",
            "    }",
            "    template<class ...T>",
            "    void build(int u,int l,int r,const T&...args) {",
            "        lz[u].init();",
            "        if(l==r) return tr[u].init(l,args...);",
            "        int mid=(l+r)>>1;",
            "        build(u1,l,mid,args...);",
            "        build(u2,mid+1,r,args...);",
            "        tr[u]=tr[u1]+tr[u2];",
            "    }",
            "    void push_lazy(int u,int l,int r) {",
            "        tr[u].add(lz[u],l,r);",
            "        if(l!=r) lz[u1].unite(lz[u]),lz[u2].unite(lz[u]);",
            "        lz[u].init();",
            "    }",
            "    void change(int l,int r,const Tag &val) {",
            "        if(Lpoint<=l&&l<=r&&r<=Rpoint)",
            "            change(1,Lpoint,Rpoint,l,r,val);",
            "    }",
            "    void change(int u,int l,int r,int ql,int qr,const Tag &val) {",
            "        push_lazy(u,l,r);",
            "        if(l==ql&&r==qr) lz[u]=val;",
            "        else {",
            "            int mid=(l+r)>>1;",
            "            if(qr<=mid) change(u1,l,mid,ql,qr,val);",
            "            else if(ql>mid) change(u2,mid+1,r,ql,qr,val);",
            "            else change(u1,l,mid,ql,mid,val),change(u2,mid+1,r,mid+1,qr,val);",
            "            push_lazy(u1,l,mid),push_lazy(u2,mid+1,r);",
            "            tr[u]=tr[u1]+tr[u2];",
            "        }",
            "    }",
            "    Data query(int l,int r) {",
            "        return query(1,Lpoint,Rpoint,l,r);",
            "    }",
            "    Data query(int u,int l,int r,int ql,int qr) {",
            "        push_lazy(u,l,r);",
            "        if(l==ql&&r==qr) return tr[u];",
            "        int mid=(l+r)>>1;",
            "        if(qr<=mid) return query(u1,l,mid,ql,qr);",
            "        if(ql>mid) return query(u2,mid+1,r,ql,qr);",
            "        return query(u1,l,mid,ql,mid)+query(u2,mid+1,r,mid+1,qr);",
            "    }",
            "    #undef u1",
            "    #undef u2",
            "};",
        ],
    },
    "read快读快写": {
        "prefix": "#read快读快写",
        "body": [
            "/// @warning 只用快读之后，不能再使用scanf和cin读入",
            "namespace FASTIO {",
            "    constexpr int MAXBUF = 1e6;",
            "    char buf[MAXBUF], *pl, *pr;",
            "    #define gc() (pl == pr && (pr = (pl = buf)  \\",
            "        + fread(buf, 1, MAXBUF, stdin), pl == pr) ? EOF : *pl++)",
            "    template<typename T>",
            "    bool read(T& x) {",
            "        x = 0;",
            "        bool neg = false;",
            "        char c = gc();",
            "        if(c == EOF) return false;",
            "        while(c<'0' or c>'9') {",
            "            if(c == '-') neg = true;",
            "            c = gc();",
            "            if(c == EOF) return false;",
            "        }",
            "        while(c>='0' and c<='9') {",
            "            x = (x<<3) + (x<<1) + (c^48);",
            "            c = gc();",
            "            if(c == EOF) return false;",
            "        }",
            "        if(neg) x = -x;",
            "        return true;",
            "    }",
            "    template<typename T, typename ...Ts>",
            "    bool read(T& x, Ts& ...args) {",
            "        return read(x) and read(args...);",
            "    }",
            "    template<typename T>",
            "    void write(T x) {",
            "        if(x<0) putchar('-'), x = -x;",
            "        if(x>9) write(x/10);",
            "        putchar(x%10 + '0');",
            "    }",
            "}",
            "using namespace FASTIO;",
        ],
    },
    "exgcd扩欧": {
        "prefix": "#exgcd扩欧",
        "body": [
            "template<class T>",
            "T exgcd(T a,T b,T& x,T& y) {// |x|<=|a|,|y|<=|b|",
            "    if(!b) return x=1, y=0, a;",
            "    T d=exgcd(b,a%b,x,y), t=x;",
            "    x=y, y=t-a/b*y;",
            "    return d;",
            "}",
        ],
    },
    "sieve": {
        "prefix": "#sieve欧拉筛",
        "body": [
            "vector<bool> nPrime;",
            "vector<int> prm,minp,phi,mo;",
            "void sieve(int n) {// sieve [1,n]",
            "    nPrime.resize(n+1), nPrime[1]=true;",
            "    minp.resize(n+1);",
            "    phi.resize(n+1), phi[1]=1;",
            "    mo.resize(n+1), mo[1]=1;",
            "    for(int i=2; i<=n; ++i) {",
            "        if(!nPrime[i]) {",
            "            prm.push_back(i);",
            "            minp[i]=i;",
            "            phi[i]=i-1;",
            "            mo[i]=-1;",
            "        }",
            "        for(int j=0; prm[j]<=n/i; ++j) {",
            "            int k=i*prm[j];",
            "            nPrime[k]=true;",
            "            minp[k]=prm[j];",
            "            if (i%prm[j]==0) {",
            "                phi[k]=phi[i]*prm[j];",
            "                break;",
            "            }",
            "            phi[k]=phi[i]*(prm[j]-1);",
            "            mo[k]=-mo[i];",
            "        }",
            "    }",
            "}",
        ],
    },
    "excrt扩展中国": {
        "prefix": "#excrt扩展中国剩余定理",
        "body": [
            "template<class T>",
            "T exgcd(T a,T b,T& x,T& y) {// |x|<=|a|,|y|<=|b|",
            "    if(!b) return x=1, y=0, a;",
            "    T d=exgcd(b,a%b,x,y), t=x;",
            "    x=y, y=t-a/b*y;",
            "    return d;",
            "}",
            "bool excrt(ll& a1, ll& m1, ll a2, ll m2) {",
            "    // ans = k1*m1+a1 = k2*m2+a2",
            "    ll x, y, gcd=exgcd(m1, m2, x, y), dx=m2/gcd;",
            "    if ((a2-a1)%gcd) return false;",
            "    x=((__int128_t)(a2-a1)/gcd*x%dx+dx)%dx;",
            "    a1+=m1*x, m1*=m2/gcd;",
            "    return true;",
            "}",
        ],
    },
    "Factorial Preprocessing": {
        "prefix": "#factorial预处理阶乘",
        "body": [
            "vector<Z> inv, fac, infac;",
            "void initFac(int n) {",
            "    n = min(n, P-1);",
            "    inv.resize(n+1, 1);",
            "    fac.resize(n+1, 1);",
            "    infac.resize(n+1, 1);",
            "    for(int i=2; i<=n; ++i) {",
            "        fac[i] = fac[i-1] * i;",
            "        inv[i] = -P/i * inv[P%i];",
            "        infac[i] = infac[i-1] * inv[i];",
            "    }",
            "}",
            "Z binom(int n, int m) {// n,m<P",
            "    if(m < 0 or n < m) return 0;",
            "    assert(n < fac.size());",
            "    return fac[n] * infac[m] * infac[n-m];",
            "}",
        ],
    },
    "Dsu并查集": {
        "prefix": "#Dsu_with_size 并查集，有size属性",
        "body": [
            "struct Dsu {",
            "    vector<int> fa, sz;",
            "    Dsu(int n): fa(n),sz(n,1) {",
            "        iota(fa.begin(), fa.end(), 0);",
            "    }",
            "    bool unite(int x, int y) {",
            "       x=get(x), y=get(y);",
            "       if(x==y) return false;",
            "       fa[x]=y;",
            "       sz[y]+=sz[x];",
            "       return true;",
            "    }",
            "    int get(int x) {",
            "        return fa[x]==x ? x: fa[x]=get(fa[x]);",
            "    }",
            "    int size(int x) {",
            "        return sz[get(x)];",
            "    }",
            "};",
        ],
    },
    "addEdge链式前向星建图": {
        "prefix": "#addEdge链式前向星建图",
        "body": [
            "struct Enode {",
            "    int next, t;",
            "    int l;",
            "} edge[int(2e6)+10];",
            "int en, head[N];",
            "void initGraph(int n) {",
            "    fill_n(head, n+1, -1), en = 0;",
            "}",
            "template<class... T>",
            "void addEdge(int x, int y, T... args){",
            "    edge[en] = {head[x], y, args...};",
            "    head[x] = en++;",
            "}",
        ],
    },
    "树状数组": {
        "prefix": "#Bit树状数组",
        "body": [
            "template<class T>",
            "struct Bit {// index-0",
            "    int n;",
            "    vector<T> sum;",
            "    Bit(int n): n(n), sum(n) {}",
            "    void change(int p, T x) {",
            "        for(++p; p<=n; p+=p&-p) sum[p-1]+=x;",
            "    }",
            "    T query(int p) {",
            "        T res=0;",
            "        for(++p; p>0; p-=p&-p) res+=sum[p-1];",
            "        return res;",
            "    }",
            "    T query(int l, int r) {",
            "        return query(r)-query(l-1);",
            "    }",
            "};",
        ],
    },
    "Point类": {
        "prefix": "#Point类",
        "body": [
            "template<class T>",
            "int sgn(const T& v) {",
            "    static constexpr T eps = 1e-8;",
            "    return v>eps ? 1 : v<-eps ? -1 : 0;",
            "}",
            "template<class T>",
            "struct Point {// Point or Vector",
            "    T x,y;",
            "    Point() {}",
            "    Point(T x, T y): x(x), y(y) {}",
            "    template<class U>",
            "    operator Point<U> () const {",
            "        return Point<U>(U(x),U(y));",
            "    }",
            "    Point operator+(const Point& o) const {",
            "        return Point(x+o.x, y+o.y);",
            "    }",
            "    Point operator-(const Point& o) const {",
            "        return Point(x-o.x, y-o.y);",
            "    }",
            "    Point operator-() const {",
            "        return Point(-x, -y);",
            "    }",
            "    Point operator*(const T& v) const {",
            "        return Point(x*v, y*v);",
            "    }",
            "    friend Point operator*(const T& v, const Point<T>& o) {",
            "        return Point(o.x*v, o.y*v);",
            "    }",
            "    Point operator/(const T& v) const {",
            "        return Point(x/v, y/v);",
            "    }",
            "    Point operator+=(const Point& o) {",
            "        x += o.x, y += o.y;",
            "        return *this;",
            "    }",
            "    Point operator-=(const Point& o) {",
            "        x -= o.x, y -= o.y;",
            "        return *this;",
            "    }",
            "    Point operator*=(const T& v) {",
            "        x *= v, y *= v;",
            "        return *this;",
            "    }",
            "    Point operator/=(const T& v) {",
            "        x /= v, y /= v;",
            "        return *this;",
            "    }",
            "    bool operator==(const Point& o) const {",
            "        return sgn(x-o.x)==0 and sgn(y-o.y)==0;",
            "    }",
            "    bool operator!=(const Point& o) const {",
            "        return sgn(x-o.x)!=0 or sgn(y-o.y)!=0;",
            "    }",
            "    bool operator<(const Point& o) const {",
            "        return sgn(x-o.x)<0 or sgn(x-o.x)==0 and sgn(y-o.y)<0;",
            "    }",
            "    bool operator>(const Point& o) const {",
            "        return sgn(x-o.x)>0 or sgn(x-o.x)==0 and sgn(y-o.y)>0;",
            "    }",
            "    T square() const {",
            "        return x*x + y*y;",
            "    }",
            "    T interSquare(const Point& o) const {",
            "        return (*this-o).square();",
            "    }",
            "    friend istream& operator>>(istream& in, Point& o) {",
            "        return in>>o.x>>o.y;",
            "    }",
            "    friend ostream& operator<<(ostream& out, const Point<T>& o) {",
            "        return out<<\"(\"<<o.x<<\",\"<<o.y<<\")\";",
            "    }",
            "    // 涉及浮点数",
            "    double length() const {",
            "        return sqrtl(square());",
            "    }",
            "    double distance(const Point& o) const {",
            "        return (*this-o).length();",
            "    }",
            "    T absDistance(const Point& o) const {",
            "        return abs(x-o.x)+abs(y-o.y);",
            "    }",
            "    /// @brief 两向量夹角范围是 [0,PI]",
            "    double ang(const Point& o) const {",
            "        return acosl(max(-1.0l,min(1.0l,dot(o)/(length()*o.length()))));",
            "    }",
            "    /// @brief 逆时针旋转 rad",
            "    Point rotate(double rad) const {",
            "        return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad));",
            "    }",
            "    Point rotate(double cosr, double sinr) const {",
            "        return Point(x*cosr-y*sinr, x*sinr+y*cosr);",
            "    }",
            "};",
        ],
    },
    "segtree线段树(单点修改)": {
        "prefix": "#segtree线段树(单点修改)",
        "body": [
            "struct Data {",
            "    ${1:int x;}",
            "    // init(int i,const T& args... )",
            "    template<class T>",
            "    void init(int i,const T& a,const T& dfn) {",
            "        x=a[dfn[i]];",
            "    }",
            "    // add(const T& args... )",
            "    void add(int val) {",
            "        x=val;",
            "    }",
            "    friend Data operator+(const Data &lhs,const Data & rhs) {",
            "        Data re;",
            "        re.x=min(lhs.x,rhs.x);",
            "        return re;",
            "    }",
            "};",
            "struct Segtree {",
            "    #define u1 (u<<1)",
            "    #define u2 (u<<1|1)",
            "    vector<Data> tr;",
            "    vector<int> mp;",
            "    int Lpoint,Rpoint;",
            "    template<class ...T>",
            "    Segtree(int L,int R,const T&...args):Lpoint(L),Rpoint(R)",
            "    ,tr(4<<__lg(R-L+1)),mp(R-L+1) {// a[L~R]建树",
            "        build(1,L,R,args...);",
            "    }",
            "    template<class ...T>",
            "    void build(int u,int l,int r,const T&...args) {",
            "        if(l==r) {",
            "            tr[u].init(l,args...);",
            "            mp[l-Lpoint]=u;",
            "            return;",
            "        }",
            "        int mid=(l+r)>>1;",
            "        build(u1,l,mid,args...);",
            "        build(u2,mid+1,r,args...);",
            "        tr[u]=tr[u1]+tr[u2];",
            "    }",
            "    template<class ...T>",
            "    void change(int pos,const T&...args) {",
            "        int u=mp[pos-Lpoint];",
            "        tr[u].add(args...);",
            "        for (u>>=1; u; u>>=1) tr[u]=tr[u1]+tr[u2];",
            "    }",
            "    Data query(int l,int r) {",
            "        return query(1,Lpoint,Rpoint,l,r);",
            "    }",
            "    Data query(int u,int l,int r,int ql,int qr) {",
            "        if (l==ql&&r==qr) return tr[u];",
            "        int mid=(l+r)>>1;",
            "        if (qr<=mid) return query(u1,l,mid,ql,qr);",
            "        if (ql>mid) return query(u2,mid+1,r,ql,qr);",
            "        return query(u1,l,mid,ql,mid)+query(u2,mid+1,r,mid+1,qr);",
            "    }",
            "    #undef u1",
            "    #undef u2",
            "};",
        ],
    },
    "mex运算": {
        "prefix": "#mex运算",
        "body": [
            "int mex(const vector<int>& a) {",
            "    vector<int> vis(a.size()+1);",
            "    for(int x:a)",
            "        if(x<(int)a.size())",
            "            vis[x]=1;",
            "    int p=0;",
            "    while(vis[p]) p++;",
            "    return p;",
            "}",
        ],
    },
    "Modulus": {
        "prefix": "#Modint取模工具",
        "body": [
            "template<int P>",
            "struct MInt {",
            "    int x;",
            "    constexpr MInt(): x(0) {}",
            "    template<class T>",
            "    constexpr MInt(T x): x(norm(x%P)) {}",
            "    constexpr static int norm(int x) {",
            "        return x<0? x+P: x>=P? x-P: x;",
            "    }",
            "    constexpr MInt inv() const{",
            "        int a=x, b=P, u=1, v=0;",
            "        while(b) {",
            "            int t = a/b;",
            "            swap((a-=t*b), b);",
            "            swap((u-=t*v), v);",
            "        }",
            "        return u;",
            "    }",
            "    constexpr MInt operator-() const{",
            "        return MInt()-*this;",
            "    }",
            "    constexpr MInt& operator+=(const MInt& a) {",
            "        x=norm(x+a.x);",
            "        return *this;",
            "    }",
            "    constexpr MInt& operator-=(const MInt& a) {",
            "        x=norm(x-a.x);",
            "        return *this;",
            "    }",
            "    constexpr MInt& operator*=(const MInt& a) {",
            "        x=1ll*x*a.x%P;",
            "        return *this;",
            "    }",
            "    constexpr MInt& operator/=(const MInt& a) {",
            "        assert(a);",
            "        return *this*=a.inv();",
            "    }",
            "    constexpr friend MInt operator+(MInt l,const MInt& r) {",
            "        return l+=r;",
            "    }",
            "    constexpr friend MInt operator-(MInt l,const MInt& r) {",
            "        return l-=r;",
            "    }",
            "    constexpr friend MInt operator*(MInt l,const MInt& r) {",
            "        return l*=r;",
            "    }",
            "    constexpr friend MInt operator/(MInt l,const MInt& r) {",
            "        return l/=r;",
            "    }",
            "    constexpr explicit operator bool()const {",
            "        return x!=0;",
            "    }",
            "    constexpr bool operator!()const {",
            "        return x==0;",
            "    }",
            "    friend ostream& operator<<(ostream& os,const MInt& a) {",
            "        return os<<a.x;",
            "    }",
            "    string find_Fraction()const {",
            "        for(int i=1; i<=1000000; ++i)",
            "            if((*this*i).x<=100)",
            "                return to_string((*this*i).x) + \"/\" + to_string(i);",
            "        return \"not find.\";",
            "    }",
            "};",
            "constexpr int P = ${1:998244353};",
            "using Z=MInt<P>;",
            "constexpr Z power(Z a, ll b) {",
            "    Z ans(1);",
            "    for(; b; b>>=1, a*=a)",
            "        if(b&1) ans*=a;",
            "    return ans;",
            "}",
            "template<int V>// invV<2> * 2 ==1 mod P",
            "constexpr Z invV=power(V,P-2);",
            "$0",
        ],
    },
    "grid dfs header": {
        "prefix": "#grid_dfs_header遍历相邻接格子",
        "body": [
            "const vector<int> dx{0,1,0,-1};",
            "const vector<int> dy{1,0,-1,0};",
        ],
    },
    "grid dfs body": {
        "prefix": "#grid_dfs_body遍历相邻接格子",
        "body": [
            "for(int idx=0; idx<dx.size(); ++idx) {",
            "    int nx = ${1:i} + dx[idx], ny = ${2:j} + dy[idx];",
            "    if(nx<${3:0} || nx>=${4:n} || ny<${5:0} || ny>=${6:m})",
            "        continue;",
            "    $0",
            "}",
        ],
    },
    "qmi快速幂": {
        "prefix": "#qmi快速幂",
        "body": [
            "int qmi(ll a,ll b,int p) {",
            "    ll ans=1;",
            "    for(; b; b>>=1,a=a*a%p)",
            "        if(b&1) ans=ans*a%p;",
            "    return ans;",
            "}",
        ],
    },
    "inverse逆元": {
        "prefix": "#inverse",
        "body": [
            "template<class T>",
            "T inverse(T a,T m) {",
            "    T u=0,v=1,p=m;",
            "    while(a!=0) {",
            "        T t=m/a;",
            "        m-=t*a, swap(a,m);",
            "        u-=t*v, swap(u,v);",
            "    }",
            "    if(m!=1) return -1;// (a,p)>1,无逆元",
            "    return (u%p+p)%p;",
            "}",
        ],
    },
    "分解质因子factorOf": {
        "prefix": "#factorOf",
        "body": [
            "template<class T>",
            "auto factorOf(T n) {",
            "    // 优化1：用质因子试除,复杂度sqrt(n)/log(sqrt(n))",
            "    // 优化2：n<1e7,欧拉筛求minp[n],复杂度log(n)",
            "    vector<pair<T,int>> q;",
            "    for(int i=2; i<=n/i; ++i)",
            "        if(n%i==0) {",
            "            q.emplace_back(i,0);",
            "            while(n%i==0) n/=i,q.back().second++;",
            "        }",
            "    if(n>1) q.emplace_back(n,1);",
            "    return q;",
            "}",
        ],
    },
    "Interval": {
        "prefix": "#Interval区间交集并集",
        "body": [
            "struct Interval {",
            "    int l,r;",
            "    Interval(int lp=1,int rp=0):l(lp),r(rp){}",
            "    bool isEmpty() const{return l>r;}",
            "    int len() const{return isEmpty()?0:r-l+1;}",
            "    bool haveCross(const Interval& it) const{",
            "        if(isEmpty()||it.isEmpty()) return false;",
            "        if(l<=it.l) return it.l<=r;",
            "        return l<=it.r;",
            "    }",
            "    Interval operator&(const Interval& it) const{",
            "        if(isEmpty()||it.isEmpty()) return Interval();",
            "        return Interval(max(l,it.l),min(r,it.r));",
            "    }",
            "    Interval operator|(const Interval& it) {// haveCross",
            "        return Interval(min(l,it.l),max(r,it.r));",
            "    }",
            "    bool operator<(const Interval& it) const{",
            "        if(l^it.l) return l<it.l;",
            "        return r<it.r;",
            "    }",
            "    friend istream& operator>>(istream& in, Interval& it) {",
            "        return in>>it.l>>it.r;",
            "    }",
            "    friend ostream& operator<<(ostream& out, Interval it) {",
            "        if(it.isEmpty()) return out<<\"{}\";",
            "        return out<<\"{\"<<it.l<<\",\"<<it.r<<\"}\";",
            "    }",
            "};",
        ],
    },
    "manyCase": {
        "prefix": "#manyCase",
        "body": [
            "int ${1:tt};",
            "cin>>${1:tt};",
            "while(${1:tt}--) {",
            "    $0",
            "}",
        ],
    },
    "离散化": {
        "prefix": "#lsh离散化",
        "body": [
            "template<class T>",
            "auto lsh(vector<T>& A) {// return lsh's function",
            "    sort(A.begin(), A.end());",
            "    A.erase(unique(A.begin(), A.end()), A.end());",
            "    return [&](const T& x) {",
            "        return lower_bound(A.begin(), A.end(), x)-A.begin();",
            "    };",
            "}",
        ],
    },
    "二分答案": {
        "prefix": "#binarySearch二分答案",
        "body": [
            "// return the first i of [l,r],such as check(i)=true",
            "// if no such i,return r+1",
            "template<class T,class Func>",
            "T binaryMin(T l,T r,Func check) {",
            "    T ans=r+1;",
            "    while(l<=r) {",
            "        T mid=l+(r-l)/2;",
            "        if(check(mid)) {",
            "            ans=mid;",
            "            r=mid-1;",
            "        }else l=mid+1;",
            "    }",
            "    return ans;",
            "}",
            "// return the last i of [l,r],such as check(i)=true",
            "// if no such i,return l-1",
            "template<class T,class Func>",
            "T binaryMax(T l,T r,Func check) {",
            "    T ans=l-1;",
            "    while(l<=r) {",
            "        T mid=l+(r-l)/2;",
            "        if(check(mid)) {",
            "            ans=mid;",
            "            l=mid+1;",
            "        }else r=mid-1;",
            "    }",
            "    return ans;",
            "}",
        ],
    },
    "for0": {
        "prefix": "#for0",
        "body": [
            "for(int ${3:i}=${1:0}; ${3:i}<${2:n}; ++${3:i}) {",
            "    $0",
            "}",
        ],
    },
    "cin_Graph": {
        "prefix": "#cin_Graph",
        "body": [
            "int n,m;",
            "cin>>n>>m;",
            "$0",
            "for(int i=0; i<m; ++i) {",
            "    int u, v, w;",
            "    cin>>u>>v;//>>w;",
            "    // --u,--v;",
            "    ",
            "}",
        ],
    },
    "cin_array": {
        "prefix": "#cin_array",
        "body": [
            "int n;",
            "cin>>n;",
            "vector<${1:int}> a(n);",
            "for(int i=0; i<n; ++i) {",
            "    cin>>a[i];",
            "}",
        ],
    },
    "最小树形图": {
        "prefix": "minTree",
        "body": [
            "void readGraph() {",
            "        cin>>n>>m>>k;",
            "        for(int i=0; i<m; ++i) {",
            "            int u,v,w;",
            "            cin>>u>>v>>w;",
            "            g[u].emplace_back(v,w);",
            "            g[v].emplace_back(u,w);",
            "        }",
            "        memset(f, 0x3f, sizeof f);",
            "        memset(f[0], 0, sizeof f[0]);// 防止k=0输出0x3f",
            "        for(int i=0,x; i<k; ++i) {",
            "            // cin>>c[i];",
            "            cin>>x;",
            "            f[1<<i][x]=0;",
            "        }",
            "    }",
        ],
    },
    "dijkstra": {
        "prefix": "#dijkstra非负边权单源最短路",
        "body": [
            "template<class T>",
            "struct Dijkstra {",
            "    static constexpr T inf=numeric_limits<T>::max();",
            "    vector<vector<pair<int,T>>> g;",
            "    vector<T> dis;",
            "    Dijkstra(int n):g(n) {}",
            "    void addEdge(int u,int v,T w) {",
            "        g[u].emplace_back(v,w);",
            "    }",
            "    struct Node {",
            "        int u;",
            "        T dis;",
            "        bool operator<(const Node& O)const {",
            "            return dis>O.dis;",
            "        }",
            "    };",
            "    void dij(int s) {",
            "        priority_queue<Node> q;",
            "        dis.assign(g.size(),inf);",
            "        dis[s]=0;",
            "        q.push({s, 0});",
            "        while(q.size()) {",
            "            auto [u,tdis]=q.top();",
            "            q.pop();",
            "            if(tdis>dis[u]) continue;",
            "            for(auto [v,w]:g[u]) {",
            "                if(tdis < dis[v]-w) {",
            "                    dis[v]=tdis+w;",
            "                    q.push({v, dis[v]});",
            "                }",
            "            }",
            "        }",
            "    }",
            "};",
        ],
    },
    "spfa": {
        "prefix": "#spfa最短路",
        "description": "最坏O(nm)，可以判断负环",
        "body": [
            "template<class T>",
            "struct SPFA {",
            "    static constexpr T inf=numeric_limits<T>::max()/2;",
            "    int n;",
            "    vector<vector<pair<int,T>>> g;",
            "    vector<T> dis;",
            "    SPFA(int n):n(n),g(n) {}",
            "    void addEdge(int u,int v,T w) {",
            "        g[u].emplace_back(v,w);",
            "    }",
            "    bool spfa(int s) {",
            "        vector<bool> vis(n);",
            "        vector<int> cnt(n);",
            "        dis.assign(n,inf), dis[s]=0;",
            "        queue<int> q;",
            "        q.push(s), vis[s]=true;",
            "        while(q.size()) {",
            "            int u=q.front();",
            "            q.pop(), vis[u]=false;",
            "            for(auto [v,w]:g[u]) {",
            "                if(dis[u]+w < dis[v]) {",
            "                    dis[v]=dis[u]+w;",
            "                    if((cnt[v]=cnt[u]+1)>=n)",
            "                        return false;",
            "                    if(!vis[v])",
            "                        q.push(v), vis[v]=true;",
            "                }",
            "            }",
            "        }",
            "        return true;",
            "    }",
            "};",
        ],
    },
    "compare_rule": {
        "prefix": "#cmp_rule",
        "body": [
            "[&](const ${1:auto}& x,const ${1:auto}& y){",
            "    return x < y;$0",
            "}",
        ],
    },
    "整数三分": {
        "prefix": "#ternary_search",
        "body": [
            "template<bool FIND_MAX = true, typename I, class F>",
            "I ternarySearch(I l, I r, F f) {",
            "    assert(l<=r);",
            "    while(l < r) {",
            "        I lmid = l + (r - l) / 2;",
            "        I rmid = lmid + 1;",
            "        if constexpr (FIND_MAX) {",
            "            if(f(lmid) < f(rmid)) l = rmid;",
            "            else r = lmid;",
            "        }else {",
            "            if(f(lmid) < f(rmid)) r = lmid;",
            "            else l = rmid;",
            "        }",
            "    }",
            "    return l;",
            "}",
        ],
        "description": [
            "整数三分\n",
            "函数必须为单峰/单谷函数，允许存在多个最值点\n",
            "但最值处的左/右侧必须严格单调"
        ],
    },
    "chMin and chMax": {
        "prefix": "#chMax",
        "body": [
            "template<class T>",
            "void chMin(T &a, T b) {",
            "    a=min(a,b);",
            "}",
            "template<class T>",
            "void chMax(T &a, T b) {",
            "    a=max(a,b);",
            "}",
        ],
    },
    "cin_tree": {
        "prefix": "#cin_tree",
        "body": [
            "for(int i=1; i<n; ++i) {",
            "    int u,v;",
            "    cin>>u>>v;",
            "    g[u].push_back(v);",
            "    g[v].push_back(u);",
            "}",
        ],
    },
    "#debug": {
        "prefix": "#debug",
        "body": [
            "#ifdef YJL",
            "#include<debug.h>",
            "#else",
            "#define debug(...)0",
            "#endif",
        ],
    },
    "dfs_graph": {
        "prefix": "#dfs_graph",
        "body": [
            "int sz[N];",
            "void dfs(int u,int fa=-1) {",
            "    sz[u]=1;",
            "    for(int v:g[u]) {",
            "        if(v==fa) continue;",
            "        dfs(v,u);",
            "        sz[u]+=sz[v];",
            "    }",
            "}",
        ],
    },
    "pre_display": {
        "prefix": "#pre_display",
        "body": [
            "template<class Func>",
            "void pre_display(vector<int> a, Func calc_cost) {",
            "    sort(ALL(a));",
            "    ll mdis=0;",
            "    do {",
            "        ll dis=calc_cost(a);",
            "        if(dis>mdis) {",
            "            mdis=dis;",
            "        }",
            "    } while (next_permutation(ALL(a)));",
            "    ",
            "    debug(mdis);",
            "",
            "    int num=0;",
            "    sort(ALL(a));",
            "    do {",
            "        ll dis=calc_cost(a);",
            "        if(dis==mdis) {",
            "            ++num;",
            "            debug(a);",
            "        }",
            "    } while (next_permutation(ALL(a)));",
            "    cerr<< \"num = \" << num <<endl;",
            "    exit(0);",
            "}",
        ],
    },
    "lg": {
        "prefix": "#lg",
        "description": "避免__lg(0)出问题,这里lg(0)==-1",
        "body": [
            "#define lg(x) ((x)?__lg(x):-1)",
        ],
    },
    "eq_xxxx_series": {
        "prefix": "#eq_rate_series,eq_diff_series",
        "description": "等比数列求和，等差数列求和",
        "body": [
            "Z eq_rate_series(Z a, int64_t q, int64_t n) {",
            "    if(n<=0) return 0;",
            "    if(q==1) return Z(a)*n;",
            "    return a * (power(q,n)-1) / (q-1);",
            "}",
            "Z eq_diff_series(Z a, int64_t d, int64_t n) {",
            "    if(n<=0) return 0;",
            "    return n * (a+a+Z(n-1)*d) * invV<2>;",
            "}",
        ],
    },
    "DSU_iterator": {
        "prefix": "#DSU_iterator",
        "description": "并查集遍历加速",
        "body": [
            "struct DSU {",
            "    int n;",
            "    vector<int> vis, nxt;",
            "    DSU(int n): n(n), vis(n), nxt(n) {",
            "        iota(nxt.begin(),nxt.end(),1);",
            "    }",
            "    int next(int i) {",
            "        if(nxt[i]>=n)",
            "            return n;",
            "        if(vis[nxt[i]])",
            "            nxt[i]=this->next(nxt[i]);",
            "        return nxt[i];",
            "    }",
            "    void set(int i) {",
            "        vis[i]=1;",
            "    }",
            "    int begin(int i) {",
            "        while(i<n && vis[i])",
            "            i=this->next(i);",
            "        return i;",
            "    }",
            "};",
        ],
    },
    "cin_array2D": {
        "prefix": "#cin_array2D",
        "description": "输出二维数组",
        "body": [
            "int n,m;",
            "cin>>n>>m;",
            "vector<vector<${1:int}>> a(n,vector<${1:int}>(m));",
            "for(int i=0; i<n; ++i) {",
            "    for(int j=0; j<m; ++j) {",
            "        cin>>a[i][j];",
            "    }",
            "}",
        ],
    },
    "solve": {
        "prefix": "#solve",
        "description": "lambda表达式代替solve",
        "body": [
            "[&](){",
            "    $0",
            "}();",
        ],
    },
    "Dsu": {
        "prefix": "#Dsu并查集",
        "description": "最基础的并查集",
        "body": [
            "struct Dsu {",
            "    vector<int> fa;",
            "    Dsu(int n): fa(n) {",
            "        iota(fa.begin(), fa.end(), 0);",
            "    }",
            "    bool unite(int x, int y) {",
            "       x=get(x), y=get(y);",
            "       if(x==y) return false;",
            "       fa[x]=y;",
            "       return true;",
            "    }",
            "    int get(int x) {",
            "        return fa[x]==x ? x: fa[x]=get(fa[x]);",
            "    }",
            "};",
        ],
    },
    "topoSort": {
        "prefix": "#topoSort DAG拓扑排序",
        "description": "对有向无环图进行拓扑排序 和 dp转移",
        "body": [
            "/// @param func func(u,v): u -\\> v",
            "void topo(const vector<vector<int>>& g, function<void(int,int)> func) {",
            "    int n=g.size();",
            "    vector<int> in(n);",
            "    for(int u=0; u<n; ++u)",
            "        for(auto v:g[u])",
            "            ++in[v];",
            "    queue<int> q;",
            "    for(int i=0; i<n; ++i)",
            "        if(!in[i]) q.push(i);",
            "    while(q.size()) {",
            "        int u=q.front();",
            "        q.pop();",
            "        for(auto v:g[u]) {",
            "            func(u,v);",
            "            if(--in[v]==0)",
            "                q.push(v);",
            "        }",
            "    }",
            "}",
            "/// @param func func(u,v,w): u -\\> v",
            "void topo(const vector<vector<pair<int,int>>>& g, function<void(int,int,int)> func) {",
            "    int n=g.size();",
            "    vector<int> in(n);",
            "    for(int u=0; u<n; ++u)",
            "        for(auto [v,w]:g[u])",
            "            ++in[v];",
            "    queue<int> q;",
            "    for(int i=0; i<n; ++i)",
            "        if(!in[i]) q.push(i);",
            "    while(q.size()) {",
            "        int u=q.front();",
            "        q.pop();",
            "        for(auto [v,w]:g[u]) {",
            "            func(u, v, w);",
            "            if(--in[v]==0)",
            "                q.push(v);",
            "        }",
            "    }",
            "}",
        ],
    },
    "tarjan_ecc": {
        "prefix": "#tarjan_ecc无向图边连通分量",
        "description": "",
        "body": [
            "struct Tarjan {",
            "    int n,dn,bn,index;",
            "    vector<vector<pair<int,int>>> g;",
            "    vector<vector<int>> ecc;",
            "    vector<int> dfn,low,bel;",
            "    stack<int> st;",
            "    Tarjan(int n):n(n),dn(0),bn(0),index(0),g(n),dfn(n),low(n),bel(n) {}",
            "    void addEdge(int u,int v) {",
            "        g[u].emplace_back(v,index++);",
            "        g[v].emplace_back(u,index++);",
            "    }",
            "    void tarjan(int u,int index) {",
            "        dfn[u]=low[u]=++dn;",
            "        st.push(u);",
            "        for(auto [v,i]:g[u]) {",
            "            if((i^1)==index)// 防止立马回头",
            "                continue;",
            "            if(!dfn[v]) {",
            "                tarjan(v,i);",
            "                low[u]=min(low[u], low[v]);",
            "                // if(dfn[u]<low[v]) {}// 割边",
            "            }else {",
            "                low[u]=min(low[u], dfn[v]);// 返祖边",
            "            }",
            "        }",
            "        if(dfn[u]==low[u]) {",
            "            vector<int> cur;",
            "            for(int v=-1; v!=u; ) {",
            "                v=st.top();",
            "                st.pop();",
            "                bel[v]=bn;",
            "                cur.push_back(v);// 连通分量的信息",
            "            }",
            "            ecc.emplace_back(cur);",
            "            bn++;",
            "        }",
            "    }",
            "    void converge() {",
            "        for(int i=0; i<n; ++i)",
            "            if(!dfn[i]) tarjan(i,-1);",
            "    }",
            "    auto newForest() {",
            "        vector<vector<int>> tr(bn);",
            "        for(int u=0; u<n; ++u)",
            "            for(auto [v,i]:g[u])",
            "                if(bel[u]!=bel[v])",
            "                    tr[bel[u]].push_back(bel[v]);",
            "        return tr;",
            "    }",
            "};",
        ],
    },
    "tarjan_vcc": {
        "prefix": "#tarjan_vcc 无向图点连通分量",
        "description": "",
        "body": [
            "struct Tarjan {",
            "    int n,dn,rt;",
            "    vector<vector<int>> g;",
            "    vector<vector<int>> vcc;",
            "    vector<int> dfn,low,cut;",
            "    stack<int> st;",
            "    Tarjan(int n):n(n),dn(0),g(n),dfn(n),low(n),cut(n) {}",
            "    void addEdge(int u,int v) {",
            "        g[u].emplace_back(v);",
            "        g[v].emplace_back(u);",
            "    }",
            "    void tarjan(int u) {",
            "        dfn[u]=low[u]=++dn;",
            "        st.push(u);",
            "        int chd=0;",
            "        for(int v:g[u]) {",
            "            if(!dfn[v]) {",
            "                tarjan(v);",
            "                low[u]=min(low[u], low[v]);",
            "                if(dfn[u]<=low[v]) {",
            "                    if(u!=rt||++chd>1) cut[u]=1;// 割点",
            "                    vcc.push_back({u});",
            "                    for (int x=-1; x!=v; st.pop())",
            "                        vcc.back().push_back(x=st.top());",
            "                }",
            "            }else {// 返祖边",
            "                // 求vcc判不判回头边无所谓",
            "                low[u]=min(low[u], dfn[v]);",
            "            }",
            "        }",
            "        if(u==rt&&chd==0)// 孤点",
            "            vcc.push_back({u});",
            "    }",
            "    void converge() {",
            "        for(rt=0; rt<n; ++rt) ",
            "            if(!dfn[rt]) tarjan(rt);",
            "    }",
            "    // 圆方树/森林",
            "    auto newForest() {",
            "        vector<vector<int>> tr(n+vcc.size());// 注意孤点影响",
            "        for(int i=0; i<vcc.size(); ++i)",
            "            for(int x:vcc[i]) {",
            "                tr[n+i].push_back(x);// 方点向圆点连边",
            "                tr[x].push_back(n+i);",
            "            }",
            "        return tr;",
            "    }",
            "};",
        ],
    },
    "tarjan_scc": {
        "prefix": "#tarjan_scc 有向图强连通分量",
        "description": "",
        "body": [
            "struct Tarjan {",
            "    int n,dn,bn;",
            "    vector<vector<int>> g;",
            "    vector<int> dfn,low,insta,bel;",
            "    stack<int> st;",
            "    Tarjan(int n):n(n),dn(0),bn(0),g(n),dfn(n),low(n),insta(n),bel(n) {}",
            "    void addEdge(int u,int v) {",
            "        g[u].push_back(v);",
            "    }",
            "    void tarjan(int u) {",
            "        dfn[u]=low[u]=++dn;",
            "        st.push(u), insta[u]=1;",
            "        for(int v:g[u]) {",
            "            if(!dfn[v]) {",
            "                tarjan(v);",
            "                low[u]=min(low[u], low[v]);",
            "            }else if(insta[v])// 返祖边和横插边",
            "                low[u]=min(low[u], dfn[v]);",
            "        }",
            "        if(dfn[u]==low[u]) {",
            "            for(int v=-1; v!=u; ) {",
            "                v=st.top();",
            "                insta[v]=0, st.pop();",
            "                bel[v]=bn;",
            "                // sum[bn]+=a[v];// 连通分量的信息",
            "            }",
            "            bn++;",
            "        }",
            "    }",
            "    void converge() {",
            "        for(int i=0; i<n; ++i)",
            "            if(!dfn[i]) tarjan(i);",
            "    }",
            "    auto newDAG() {",
            "        vector<vector<int>> graph(bn);",
            "        for(int u=0; u<n; ++u)",
            "            for(int v:g[u])",
            "                if(bel[u]!=bel[v])",
            "                    graph[bel[u]].push_back(bel[v]);",
            "        return graph;",
            "    }",
            "};",
        ],
    },
    "kosaraju": {
        "prefix": "#kosaraju 有向图强连通分量",
        "description": "",
        "body": [
            "struct Kosaraju {",
            "    int n,belNum;",
            "    vector<vector<int>> g,rg;",
            "    vector<int> popS,vis,bel;",
            "    Kosaraju(int n): n(n),belNum(0),g(n),rg(n),vis(n),bel(n) {}",
            "    void addEdge(int u,int v) {",
            "        g[u].push_back(v);",
            "        rg[v].push_back(u);",
            "    }",
            "    void dfs1(int u) {",
            "        vis[u]=1;",
            "        for(int v:g[u])",
            "            if(!vis[v]) dfs1(v);",
            "        popS.push_back(u);",
            "    }",
            "    void dfs2(int u) {",
            "        vis[u]=0;",
            "        bel[u]=belNum;",
            "        // sum[belNum]+=a[u];",
            "        for(int v:rg[u])",
            "            if(vis[v]) dfs2(v);",
            "    }",
            "    void converge() {",
            "        for(int i=0; i<n; ++i)",
            "            if(!vis[i]) dfs1(i);",
            "        for(; popS.size(); popS.pop_back())",
            "            if(vis[popS.back()]) {",
            "                dfs2(popS.back());",
            "                ++belNum;",
            "            }",
            "    }",
            "    auto newDAG() {",
            "        vector<vector<int>> graph(belNum);",
            "        for(int u=0; u<n; ++u)",
            "            for(int v:g[u])",
            "                if(bel[u]!=bel[v])",
            "                    graph[bel[u]].push_back(bel[v]);",
            "        return graph;",
            "    }",
            "};",
        ],
    },
    "dinic": {
        "prefix": "#dinic最大流",
        "description": "",
        "body": [
            "namespace NetFlow {",
            "    using T = long long;",
            "    constexpr T INF = numeric_limits<T>::max()/2;",
            "    constexpr int _V = 2e5 + 10;",
            "    constexpr int _E = 2e6 + 10;",
            "    int s0, t0, _n, head[_V], dis[_V], to[_E], nxt[_E], en;",
            "    T fl[_E];",
            "    void initGraph(int n = _V-2) {",
            "        _n = n, s0 = _n++, t0 = _n++, en = 0, fill_n(head, _n, -1);",
            "    }",
            "    void addEdge(int x, int y, T z) {",
            "        assert(x<_V && y<_V), assert(en+1<_E);",
            "        to[en] = y, nxt[en] = head[x], fl[en] = z, head[x] = en++;",
            "        to[en] = x, nxt[en] = head[y], fl[en] = 0, head[y] = en++;",
            "    }",
            "    bool bfs(int s,int t) {",
            "        fill_n(dis, _n, -1);",
            "        queue<int> q;",
            "        q.push(s), dis[s]=0;",
            "        while(q.size()) {",
            "            int u=q.front();",
            "            q.pop();",
            "            for (int i=head[u]; ~i; i=nxt[i])",
            "                if(dis[to[i]]==-1 && fl[i]>0)",
            "                    q.push(to[i]), dis[to[i]] = dis[u]+1;",
            "        }",
            "        return dis[t] != -1;",
            "    }",
            "    T dfs(int u, int t, T flow) {",
            "        if(u==t) return flow;",
            "        T ans = flow;",
            "        for (int i=head[u]; ~i && ans; i=nxt[i]) {",
            "            int v = to[i];",
            "            if (dis[v] == dis[u]+1 && fl[i]>0) {",
            "                T temp=dfs(v, t, min(fl[i], ans));",
            "                fl[i] -= temp;",
            "                fl[i^1] += temp;",
            "                ans -= temp;",
            "            }",
            "        }",
            "        if(ans == flow) dis[u] = -1;",
            "        return flow - ans;",
            "    }",
            "    T dinic(int s,int t) {",
            "        T ans=0;",
            "        while(bfs(s,t)) ans += dfs(s, t, INF);",
            "        return ans;",
            "    }",
            "}",
            "using namespace NetFlow;",
        ],
    },
    "JudgeBG": {
        "prefix": "#BG二分图判断",
        "description": "",
        "body": [
            "struct JudgeBG {",
            "    int n;",
            "    vector<int> bel;// bel:1 or 2",
            "    vector<vector<int>> g;",
            "    JudgeBG(int n): n(n),g(n),bel(n) {}",
            "    void addEdge(int u,int v) {",
            "        g[u].push_back(v);",
            "        g[v].push_back(u);",
            "    }",
            "    bool dfs(int u, int color=1) {",
            "        if(bel[u])",
            "            return bel[u]==color;",
            "        bel[u]=color;",
            "        for(int v:g[u])",
            "            if(!dfs(v, 3-color))",
            "                return false;",
            "        return true;",
            "    }",
            "    bool paint() {// 二分图染色",
            "        for(int i=0; i<n; ++i) {",
            "            if(bel[i]) continue;",
            "            if(!dfs(i)) return false;",
            "        }",
            "        return true;",
            "    }",
            "    // vector<int> to;//[0,ln), [0,rn)",
            "    // //  use it to divide the graph if paint()=true",
            "    // BipartiteGraph reLabel() {// left->right",
            "    //     int ln=0,rn=0;",
            "    //     to.resize(n);",
            "    //     for(int i=0; i<n; ++i) {",
            "    //         if(bel[i]==1)",
            "    //             to[i]=ln++;",
            "    //         else",
            "    //             to[i]=rn++;",
            "    //     }",
            "    //     BipartiteGraph bg(ln,rn);",
            "    //     for(int i=0; i<n; ++i)",
            "    //         for(int j:g[i])",
            "    //             if(bel[i]==1)",
            "    //                 bg.addEdge(to[i],to[j]);",
            "    //     return bg;",
            "    // }",
            "};",
        ],
    },
    "PrimMst": {
        "prefix": "#primMst最小生成树",
        "description": "",
        "body": [
            "template<class T>",
            "struct PrimMst {",
            "    static constexpr T inf=numeric_limits<T>::max();",
            "    int n;",
            "    vector<vector<pair<int,T>>> g;",
            "    vector<T> dis;",
            "    vector<bool> vis;",
            "    PrimMst(int n):n(n),g(n) {}",
            "    void addEdge(int u,int v,T w) {",
            "        g[u].emplace_back(v,w);",
            "        g[v].emplace_back(u,w);",
            "    }",
            "    struct Node {",
            "        int t;",
            "        T len;",
            "        bool operator<(const Node& O)const {",
            "            return len>O.len;",
            "        }",
            "    };",
            "    T prim() {",
            "        dis.assign(n,inf);",
            "        vis.assign(n,false);",
            "        priority_queue<Node> q;",
            "        q.push({0, 0});",
            "        T ans=0;",
            "        int cnt=0;",
            "        while(q.size()) {",
            "            auto [u,len]=q.top();",
            "            q.pop();",
            "            if(vis[u]) continue;",
            "            vis[u]=true;",
            "            ans+=len;",
            "            if(++cnt >= n) break;",
            "            for(auto [v,w]:g[u])",
            "                if(!vis[v] && w<dis[v])",
            "                    q.push({v, dis[v]=w});",
            "        }",
            "        // assert(cnt==n);",
            "        return ans;",
            "    }",
            "};",
        ],
    },
    "kruskal": {
        "prefix": "kruskalMst最小生成树",
        "description": "",
        "body": [
            "template<class T>",
            "struct KruskalMst {",
            "    int n;",
            "    vector<int> f;",
            "    vector<tuple<T,int,int>> e;",
            "    KruskalMst(int n):n(n),f(n) {}",
            "    void addEdge(int u,int v,T w) {",
            "        e.emplace_back(w,u,v);",
            "    }",
            "    int get(int u) {",
            "        return f[u]==u?u: f[u]=get(f[u]);",
            "    }",
            "    T kruskal() {",
            "        iota(f.begin(),f.end(),0);",
            "        sort(e.begin(),e.end());",
            "        T ans=0;",
            "        int cnt=0;",
            "        for(auto [w,u,v]:e) {",
            "            if((u=get(u))==(v=get(v))) continue;",
            "            f[u]=v;",
            "            ans+=w;",
            "            if(++cnt==n-1) break;",
            "        }",
            "        // assert(cnt==n-1);",
            "        return ans;",
            "    }",
            "};",
        ],
    },
    "ostream": {
        "prefix": "#ostream重载输出运算符",
        "description": "",
        "body": [
            "ostream& operator<<(ostream& os, const ${1:E}& o) {",
            "    return os << ${2:\"(\" << o.s <<\",\" <<o.t <<\",\" << o.w <<\")\";}",
            "}",
        ],
    },
    "HopcroftKarp": {
        "prefix": "#HK二分图最大匹配",
        "description": "",
        "body": [
            "struct HopcroftKarp {// index-0,O(sqrt(n)*m)",
            "    static constexpr int INF = 0x3f3f3f3f;",
            "    int n,m,dis;",
            "    vector<vector<int>> e;",
            "    vector<int> matchX,matchY,dx,dy;",
            "    vector<bool> used;",
            "    HopcroftKarp(int n,int m)",
            "    :n(n),m(m),e(n),matchX(n),matchY(m),dx(n),dy(m),used(m) {}",
            "    void addEdge(int u,int v) {// left->right",
            "        e[u].push_back(v);",
            "    }",
            "    bool searchP(){",
            "        fill(dx.begin(),dx.end(),-1);",
            "        fill(dy.begin(),dy.end(),-1);",
            "        dis = INF;",
            "        queue<int> q;",
            "        for(int i=0; i<n; ++i) ",
            "            if(matchX[i] == -1)",
            "                q.push(i), dx[i] = 0;",
            "        while(!q.empty()) {",
            "            int u = q.front(); q.pop();",
            "            if(dx[u] > dis) break;",
            "            for(int v:e[u])",
            "                if(dy[v] == -1) {",
            "                    dy[v] = dx[u] + 1;",
            "                    if(matchY[v] == -1) dis = dy[v];",
            "                    else dx[matchY[v]] = dy[v] + 1, q.push(matchY[v]);",
            "                }",
            "        }",
            "        return dis != INF;",
            "    }",
            "    bool dfs(int u){",
            "        for(int v:e[u]) {",
            "            if(used[v] || dy[v]!=dx[u]+1) continue;",
            "            used[v] = true;",
            "            if(matchY[v] != -1 && dy[v] == dis) continue;",
            "            if(matchY[v] == -1 || dfs(matchY[v])) {",
            "                matchY[v] = u;",
            "                matchX[u] = v;",
            "                return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "    int maxMatching(){",
            "        int res = 0;",
            "        fill(matchX.begin(),matchX.end(),-1);",
            "        fill(matchY.begin(),matchY.end(),-1);",
            "        while(searchP()) {",
            "            fill(used.begin(),used.end(),false);",
            "            for(int i=0; i<n; ++i) ",
            "                if(matchX[i] == -1 && dfs(i))",
            "                    ++res;",
            "        }",
            "        return res;",
            "    }",
            "};",
        ],
    },
    "floyed": {
        "prefix": "#floyed多源最短路",
        "description": "",
        "body": [
            "void floyed(vector<vector<int>>& dis) {",
            "    int n = dis.size();",
            "    for(int k=0; k<n; ++k)",
            "        for(int i=0; i<n; ++i)",
            "            for(int j=0; j<n; ++j) {",
            "                if(i!=j and i!=k and j!=k ",
            "                and dis[i][k] < inf and dis[k][j] < inf// 边权有负数必加",
            "                and dis[i][j] > dis[i][k]+dis[k][j])",
            "                    dis[i][j] = dis[i][k]+dis[k][j];",
            "            }",
            "}",
        ],
    },
    "minCostMaxFlow": {
        "prefix": "#minCostMaxFlow最小费用最大流",
        "description": "",
        "body": [
            "namespace NetFlow {",
            "    using T=int;",
            "    constexpr T INF=numeric_limits<T>::max()/2;",
            "    constexpr int _V = 5e3 + 10;",
            "    constexpr int _E = 1e6 * 2 + 10;// 双向边",
            "    int _n, s0, t0;",
            "    int head[_V], en, pre[_V];",
            "    int to[_E], nxt[_E];",
            "    T fl[_E], cost[_E], dis[_V], incf[_V], he[_V], maxf, fee;",
            "    void initGraph(int n = _V-2) {",
            "        _n = n, s0 = _n++, t0 = _n++, en = 0, fill_n(head, _n, -1);",
            "    }",
            "    void addEdge(int x, int y, T f, T Cost) {",
            "        assert(x<_V && y<_V), assert(en+1<_E);",
            "        to[en]=y, nxt[en]=head[x], fl[en]=f, cost[en]=Cost, head[x]=en++;",
            "        to[en]=x, nxt[en]=head[y], fl[en]=0, cost[en]=-Cost, head[y]=en++;",
            "    }",
            "    bool dij(int s,int t) {",
            "        using pii=pair<T,int>;",
            "        priority_queue<pii,vector<pii>,greater<>> q;",
            "        fill_n(dis, _n, INF);",
            "        dis[s]=0, incf[s]=INF, pre[t]=-1;",
            "        q.push({dis[s], s});",
            "        while(q.size()) {",
            "            auto [td, u]=q.top();",
            "            q.pop();",
            "            if(td > dis[u]) continue;",
            "            for(int i=head[u]; ~i; i=nxt[i]) {",
            "                int v=to[i];",
            "                if(fl[i]>0 && dis[v]+he[v] > dis[u]+cost[i]+he[u]) {",
            "                    dis[v] = dis[u]+cost[i]+he[u]-he[v];",
            "                    incf[v]=min(incf[u], fl[i]), pre[v]=i;",
            "                    q.push({dis[v], v});",
            "                }",
            "            }",
            "        }",
            "        return pre[t]!=-1;",
            "    }",
            "    void minCostMaxFlow(int s, int t) {",
            "        maxf = fee = 0, fill_n(he, _n, 0);",
            "        while(dij(s,t)) {",
            "            for(int u=t; u!=s; ) {",
            "                int i=pre[u];",
            "                fl[i]-=incf[t];",
            "                fl[i^1]+=incf[t];",
            "                u=to[i^1];",
            "            }",
            "            maxf += incf[t];",
            "            fee += incf[t]*(dis[t]+he[t]);",
            "            for(int i=0; i<_n; ++i)",
            "                he[i] += dis[i];// 更新势能",
            "        }",
            "    }",
            "}",
            "using namespace NetFlow;",
        ],
    },
    "KM": {
        "prefix": "#KM二分图最优匹配",
        "description": "",
        "body": [
            "struct Kuhn_Munkers {// index-1, O(n^3)",
            "    using T = int;",
            "    static constexpr int N = 1000 + 5;",
            "    static constexpr T INF = numeric_limits<T>::max()>>1;",
            "    T e[N][N], lx[N], ly[N], slack[N];",
            "    int n, matchNum, matchX[N], matchY[N], pre[N];",
            "    bool vis[N];",
            "    // 默认边权为-INF，求出的是最大匹配，在此基础之上追求权值和最大",
            "    // e0=0，求出的是最大权匹配，只追求权值和最大",
            "    void init(int n,T e0=-INF) {",
            "        this->n=n;",
            "        for(int i=1; i<=n; ++i) fill(e[i],e[i]+1+n,e0);",
            "    }",
            "    void addEdge(int u,int v,T w) {",
            "        e[u][v]=max(e[u][v],w);",
            "    }",
            "    void bfs(int u) {",
            "        fill(slack,slack+1+n,INF);",
            "        fill(pre,pre+1+n,0);",
            "        int x, y=0, yy=0;",
            "        T a;",
            "        matchY[y]=u;",
            "        for(;;) {",
            "            x = matchY[y]; a = INF, vis[y] = true;",
            "            for(int i=1; i<=n; ++i) if(!vis[i]) {",
            "                if(slack[i]+e[x][i] > lx[x]+ly[i]) {// 细节防止溢出",
            "                    slack[i] = lx[x]+ly[i]-e[x][i];",
            "                    pre[i] = y;",
            "                }",
            "                if(slack[i] < a) a=slack[i],yy = i;",
            "            }",
            "            for(int i=0; i<=n; ++i) {",
            "                if(vis[i]) lx[matchY[i]] -= a, ly[i] += a;",
            "                else slack[i] -= a;",
            "            }",
            "            y = yy;",
            "            if(!matchY[y]) break;",
            "        }",
            "        while(y) matchY[y] = matchY[pre[y]], y = pre[y];",
            "    }",
            "    T KM() {",
            "        fill(lx,lx+1+n,0);",
            "        fill(ly,ly+1+n,0);",
            "        fill(matchY,matchY+1+n,0);",
            "        for(int i=1; i<=n; ++i) {",
            "            fill(vis,vis+1+n,false);",
            "            bfs(i);",
            "        }",
            "        T ans = matchNum = 0;",
            "        for(int j=1; j<=n; ++j)",
            "            if(e[matchY[j]][j]>-INF) {// 通过-INF判断是否存在边",
            "                matchX[matchY[j]]=j;",
            "                ans += e[matchY[j]][j];",
            "                ++matchNum;",
            "            } else {",
            "                // return INF;// 没有匹配上",
            "                matchX[matchY[j]]=0;",
            "                matchY[j]=0;",
            "            }",
            "        return ans;",
            "    }",
            "} g;",
        ],
    },
    "LinearBase": {
        "prefix": "#LinearBase线性基",
        "description": "",
        "body": [
            "template<class T>",
            "struct LinearBase {",
            "    vector<T> base;",
            "    int LOG, has0;",
            "    LinearBase(int LOG): LOG(LOG),has0(0),base(LOG) {}",
            "    bool push(T x) {",
            "        for(int i=LOG-1; ~i; --i)",
            "            if(x>>i&1) {",
            "                if(!base[i]) {",
            "                    base[i]=x;",
            "                    return true;",
            "                }",
            "                x^=base[i];",
            "            }",
            "        has0=1;// get 0",
            "        return false;",
            "    }",
            "    bool query(T x) {// 是否能得到x",
            "        for(int i=LOG-1; ~i; --i)",
            "            if(x>>i&1) {",
            "                if(!base[i]) {",
            "                    return true;",
            "                }",
            "                x^=base[i];",
            "            }",
            "        return false;",
            "    }",
            "    T query_max() {",
            "        T ans(0);",
            "        for(int i=LOG-1; ~i; --i)",
            "            if((ans^base[i])>ans)",
            "                ans^=base[i];",
            "        return ans;",
            "    }",
            "    T query_min() {",
            "        if(has0)",
            "            return 0;",
            "        for(int i=0; i<LOG; ++i)",
            "            if(base[i])",
            "                return base[i];",
            "        return 0;",
            "    }",
            "    vector<T> fixed;",
            "    void rebuild() {",
            "        fixed=base;",
            "        for(int i=LOG-1; i>=0; --i)",
            "            for(int j=i-1; j>=0; --j)",
            "                if(fixed[i]>>j&1)",
            "                    fixed[i]^=fixed[j];",
            "        fixed.erase(remove(fixed.begin(),fixed.end(),T(0)),fixed.end());",
            "    }",
            "    T query_kth(T k) {",
            "        k-=has0;",
            "        if(!k)",
            "            return 0;",
            "        if(k>=1ll<<fixed.size())",
            "            return -1;",
            "        T ans(0);",
            "        for(int i=0; i<fixed.size(); ++i)",
            "            if(k>>i&1)",
            "                ans^=fixed[i];",
            "        return ans;",
            "    }",
            "};",
        ],
    },
    "NetFlow": {
        "prefix": "#NetFlow最大流",
        "description": "",
        "body": [
            "namespace NetFlow {",
            "    using T = int;",
            "    constexpr T INF = numeric_limits<T>::max()/2;",
            "    constexpr int _V = 2e5 + 10;",
            "    constexpr int _E = 2e6 + 10;",
            "    int s0, t0, _n, head[_V], dis[_V], to[_E], nxt[_E], en;",
            "    T fl[_E];",
            "    void initGraph(int n = _V-2) {",
            "        _n = n, s0 = _n++, t0 = _n++, en = 0, fill_n(head, _n, -1);",
            "    }",
            "    void addEdge(int x, int y, T z) {",
            "        assert(x<_V && y<_V), assert(en+1<_E);",
            "        to[en] = y, nxt[en] = head[x], fl[en] = z, head[x] = en++;",
            "        to[en] = x, nxt[en] = head[y], fl[en] = 0, head[y] = en++;",
            "    }",
            "    bool bfs(int s,int t) {",
            "        fill_n(dis, _n, -1);",
            "        queue<int> q;",
            "        q.push(s), dis[s]=0;",
            "        while(q.size()) {",
            "            int u=q.front();",
            "            q.pop();",
            "            for (int i=head[u]; ~i; i=nxt[i])",
            "                if(dis[to[i]]==-1 && fl[i]>0)",
            "                    q.push(to[i]), dis[to[i]] = dis[u]+1;",
            "        }",
            "        return dis[t] != -1;",
            "    }",
            "    T dfs(int u, int t, T flow) {",
            "        if(u==t) return flow;",
            "        T ans = flow;",
            "        for (int i=head[u]; ~i && ans; i=nxt[i]) {",
            "            int v = to[i];",
            "            if (dis[v] == dis[u]+1 && fl[i]>0) {",
            "                T temp=dfs(v, t, min(fl[i], ans));",
            "                fl[i] -= temp;",
            "                fl[i^1] += temp;",
            "                ans -= temp;",
            "            }",
            "        }",
            "        if(ans == flow) dis[u] = -1;",
            "        return flow - ans;",
            "    }",
            "    T dinic(int s,int t) {",
            "        T ans=0;",
            "        while(bfs(s,t)) ans += dfs(s, t, INF);",
            "        return ans;",
            "    }",
            "}",
            "using namespace NetFlow;",
        ],
    },
    "divide_array": {
        "prefix": "#divide_array划分一个数组",
        "description": "按连续相同的值划分一个数组",
        "body": [
            "for(int i=0,ii; i<${2:n}; i=ii) {",
            "    for(ii=i+1; ii<${2:n} and ${1:a}[i]==${1:a}[ii]; ii++);",
            "    // [i, ii)",
            "    $0",
            "}",
        ],
    },
    "#rand": {
        "prefix": "#rand随机数",
        "description": "",
        "body": [
            "#include<random>",
            "mt19937_64 rng(random_device{}());",
            "ll rdi(ll l, ll r) {",
            "    return rng() % (r-l+1) + l;",
            "}",
        ],
    },
    "#dp_by_change_root": {
        "prefix": "#dp_by_change_root 换根dp",
        "description": "",
        "body": [
            "void Link(int u, int v, int w=1) {// update from bottom to top",
            "    // TODO u -> v",
            "    dp[u]+=dp[v]+w;",
            "}",
            "void cut(int u, int v, int w=1) {// update from top to bottom",
            "    // TODO u -\\> v",
            "    dp[u]-=dp[v]+w;",
            "}",
            "void dfs1(int u, int fa) {",
            "    // TODO u是孤点，初始化u的所有属性",
            "    dp[u].e[0]=1;",
            "    for (int i=head[u]; ~i; i=edge[i].next) {",
            "        int v=edge[i].t, w=edge[i].l;",
            "        if (v!=fa) {",
            "            dfs1(v,u);",
            "            Link(u,v,w);",
            "        }",
            "    }",
            "}",
            "void dfs2(int u, int fa) {",
            "    // TODO 统计u作为根节点的信息",
            "    ans+=dp[u].e[0];",
            "    for (int i=head[u]; ~i; i=edge[i].next) {",
            "        int v=edge[i].t, w=edge[i].l;",
            "        if (v!=fa) {",
            "            cut(u,v,w);// u把v子树拆分出去",
            "            Link(v,u,w);// v变成根节点",
            "            dfs2(v,u);",
            "            cut(v,u,w);",
            "            Link(u,v,w);",
            "        }",
            "    }",
            "}",
        ],
    },
    "#miller_rabin": {
        "prefix": "#miller_rabin",
        "description": "Miller Rabin素性测试和Pollard rho大整数分解",
        "body": [
            "#include<random>",
            "using i64 = long long;",
            "using i128 = __int128_t;",
            "i64 power(i64 a, i64 r, i64 mod) {",
            "  i64 res = 1;",
            "  for (; r; r >>= 1, a = (i128)a * a % mod) {",
            "    if (r & 1) { res = (i128)res * a % mod; }",
            "  }",
            "  return res;",
            "}",
            "bool miller_rabin(i64 n) {",
            "  static constexpr array<int, 9> p = {2, 3, 5, 7, 11, 13, 17, 19, 23};",
            "  if (n == 1) { return false; }",
            "  if (n == 2) { return true; }",
            "  if (not(n % 2)) { return false; }",
            "  int r = __builtin_ctzll(n-1);",
            "  i64 d = (n - 1) >> r;",
            "  for (int pi : p) {",
            "    if (pi < n) {",
            "      i64 x = power(pi, d, n);",
            "      if (x == 1 or x == n - 1) { continue; };",
            "      for (int j = 1; j < r; j += 1) {",
            "        x = (i128)x * x % n;",
            "        if (x == n - 1) { break; }",
            "      }",
            "      if (x != n - 1) { return false; }",
            "    }",
            "  }",
            "  return true;",
            "};",
            "vector<i64> pollard_rho(i64 n) {",
            "  static mt19937_64 mt;",
            "  uniform_int_distribution uid(i64(0), n);",
            "  if (n == 1) { return {}; }",
            "  vector<i64> res;",
            "  function<void(i64)> rho = [&](i64 n) {",
            "    if (miller_rabin(n)) { return res.push_back(n); }",
            "    i64 d = n;",
            "    while (d == n) {",
            "      d = 1;",
            "      for (i64 k = 1, y = 0, x = 0, s = 1, c = uid(mt); d == 1;",
            "           k <<= 1, y = x, s = 1) {",
            "        for (int i = 1; i <= k; i += 1) {",
            "          x = ((i128)x * x + c) % n;",
            "          s = (i128)s * abs(x - y) % n;",
            "          if (not(i % 127) or i == k) {",
            "            d = gcd(s, n);",
            "            if (d != 1) { break; }",
            "          }",
            "        }",
            "      }",
            "    }",
            "    rho(d);",
            "    rho(n / d);",
            "  };",
            "  rho(n);",
            "  return res;",
            "}",
        ],
    },
    "#Manacher": {
        "prefix": "#Manacher 马拉车算法",
        "description": "",
        "body": [
            "template <typename T>",
            "vector<int> manacher(const T &s) {",
            "  int n = s.size();",
            "  if(!n) return {};",
            "  vector<int> res(2*n-1, 0);",
            "  int l = -1, r = -1;",
            "  for(int z=0; z < 2*n-1; ++z) {",
            "    int i = (z+1)/2, j = z/2;",
            "    int p = (i >= r ? 0 : min(r-i, res[2*(l+r)-z]));",
            "    while(j+p+1 < n and i-p-1 >= 0 and s[j+p+1] == s[i-p-1]) p++;",
            "    if(j+p > r) l = i-p, r = j+p;",
            "    res[z] = p;",
            "  }",
            "  return res;",
            "  // res[2 * i] = odd radius in position i",
            "  // res[2 * i + 1] = even radius between positions i and i + 1",
            "  // s = \"abaa\" -> res = {0, 0, 1, 0, 0, 1, 0}",
            "  // in other words, for every z from 0 to 2 * n - 2:",
            "  // calculate i = (z + 1) >> 1 and j = z >> 1",
            "  // now there is a palindrome from i - res[z] to j + res[z]",
            "  // (watch out for i > j and res[z] = 0)",
            "}",
        ],
    },
    "#zfunc": {
        "prefix": "#zfunc Z函数",
        "description": "",
        "body": [
            "// z[i]表示 s 和 s[i:] 匹配的最大长度",
            "vector<int> zfunc(const string &s) {",
            "    int n=s.size();",
            "    vector<int> z(n);",
            "    for(int i=1,l=0,r=0;i<n;i++) {",
            "        if(i<=r) z[i]=min(z[i-l],r-i+1);",
            "        while(i+z[i]<n&&s[i+z[i]]==s[z[i]]) z[i]++;",
            "        if(i+z[i]-1>r) l=i,r=i+z[i]-1;",
            "    }",
            "    z[0]=n;",
            "    return z;",
            "}",
        ],
    },
    "#PSegtree": {
        "prefix": "#PSegtree可持久化线段树",
        "description": "",
        "body": [
            "namespace {",
            "    constexpr int M = N * 32;",
            "    using T = int;",
            "    int t[N], tot, lch[M], rch[M];",
            "    T sum[M];",
            "    void cpy(int from, int to) {",
            "        lch[to]=lch[from];",
            "        rch[to]=rch[from];",
            "        sum[to]=sum[from];",
            "    }",
            "    void change(int &u, int old, int l, int r, int pos, T val) {",
            "        u=++tot;",
            "        cpy(old, u);",
            "        sum[u]+=val;",
            "        if(l==r) return;",
            "        int mid=l+(r-l)/2;",
            "        if(pos<=mid) change(lch[u], lch[u], l, mid, pos, val);",
            "        else change(rch[u], rch[u], mid+1, r, pos, val);",
            "    }",
            "    int kthSmall(int s, int t, int l, int r, int k) {// 查询区间第k小",
            "        if(l==r) return l;",
            "        int mid=l+(r-l)/2;",
            "        if(k<=sum[lch[t]]-sum[lch[s]])",
            "            return kthSmall(lch[s],lch[t],l,mid,k);",
            "        else return kthSmall(rch[s],rch[t],mid+1,r,",
            "            k-(sum[lch[t]]-sum[lch[s]]));",
            "    }",
            "    T query(int s, int t, int l, int r, int ql, int qr) {",
            "        if(l==ql&&r==qr) return sum[t]-sum[s];",
            "        int mid=l+(r-l)/2;",
            "        if(qr<=mid) return query(lch[s], lch[t], l, mid, ql, qr);",
            "        else if(ql>mid) return query(rch[s], rch[t], mid+1, r, ql, qr);",
            "        return query(lch[s], lch[t], l, mid, ql, mid)",
            "                +query(rch[s], rch[t], mid+1, r, mid+1, qr);",
            "    }",
            "    // int query(int l,int r,int L,int R) {",
            "    //     if(l>r || L>R) return 0;",
            "    //     return query(t[l-1], t[r], 1, n, L, R);",
            "    // }",
            "}",
        ],
    },
    "bfs": {
        "prefix": "#bfs",
        "description": "广度优先搜索",
        "body": [
            "vector<int> bfs(vector<vector<int>> const& g, int s) {",
            "    const int n = g.size();",
            "    vector<int> dis(n, n), q{s};",
            "    dis[s] = 0;",
            "    for(int i=0; i<q.size(); ++i) {",
            "        int u = q[i];",
            "        for(auto v:g[u]) {",
            "            if(dis[v] > dis[u] + 1) {",
            "                dis[v] = dis[u] + 1;",
            "                q.push_back(v);",
            "            }",
            "        }",
            "    }",
            "    return dis;",
            "}",
        ],
    },
    "bfs01": {
        "prefix": "#bfs01",
        "description": "边权只有0和1的最短路",
        "body": [
            "vector<int> bfs01(vector<vector<pair<int,int>>> const& g, int s) {",
            "    const int n=g.size();",
            "    vector<int> dis(n, n);",
            "    dis[s] = 0;",
            "    deque<int> q;",
            "    q.push_back(s);",
            "    while(q.size()) {",
            "        int u = q.front();",
            "        q.pop_front();",
            "        for(auto& [v,w]:g[u]) {",
            "            if(dis[v] > dis[u] + w) {",
            "                dis[v] = dis[u] + w;",
            "                if(w) q.push_back(v);",
            "                else q.push_front(v);",
            "            }",
            "        }",
            "    }",
            "    return dis;",
            "}",
        ],
    },
    "const expression": {
        "prefix": "#constexpr常量表达式",
        "description": "",
        "body": [
            "constexpr ${1:int} ${2:N} = ${0}2e5 + 10;"
        ],
    },
    "#operator": {
        "prefix": "#operator重载运算符",
        "description": "",
        "body": [
            "${1:bool} operator${2:<}(${3:Node} const& o) const {",
            "    return ${4:x < o.x};",
            "}",
        ],
    },
    "str hash": {
        "prefix": "#strHash字符串哈希",
        "description": "",
        "body": [
            "namespace str {",
            "    constexpr int P [] = {1'000'000'007, 1'000'000'009};",
            "    constexpr int B [] = {127, 131};",
            "    constexpr int PN = sizeof(P) / sizeof(int);",
            "    struct Z {",
            "        array<int, PN> v;",
            "        static constexpr Z getBase() {",
            "            Z base;",
            "            for(size_t i = 0; i < PN; ++i)",
            "                base.v[i] = B[i];",
            "            return base;",
            "        }",
            "        constexpr Z(int x = 0) {",
            "            for(int i = 0; i < PN; ++i)",
            "                v[i] = (x % P[i] + P[i]) % P[i];",
            "        }",
            "        constexpr friend Z operator+(const Z& lhs, const Z& rhs) {",
            "            Z re;",
            "            for(int i = 0; i < PN; ++i) {",
            "                re.v[i] = lhs.v[i] + rhs.v[i];",
            "                if(re.v[i] >= P[i]) re.v[i] -= P[i];",
            "            }",
            "            return re;",
            "        }",
            "        constexpr friend Z operator-(const Z& lhs, const Z& rhs) {",
            "            Z re;",
            "            for(int i = 0; i < PN; ++i) {",
            "                re.v[i] = lhs.v[i] - rhs.v[i];",
            "                if(re.v[i] < 0) re.v[i] += P[i];",
            "            }",
            "            return re;",
            "        }",
            "        constexpr friend Z operator*(const Z& lhs, const Z& rhs) {",
            "            Z re;",
            "            for(int i = 0; i < PN; ++i)",
            "                re.v[i] = 1ll * lhs.v[i] * rhs.v[i] % P[i];",
            "            return re;",
            "        }",
            "        constexpr bool operator==(const Z& o) const {",
            "            for(int i = 0; i < PN; ++i)",
            "                if(v[i] != o.v[i]) return false;",
            "            return true;",
            "        }",
            "        constexpr bool operator<(const Z& o) const {",
            "            for(int i = 0; i < PN; ++i)",
            "                if(v[i] != o.v[i]) return v[i] < o.v[i];",
            "            return false;",
            "        }",
            "        friend ostream& operator<<(ostream& os, const Z& o) {",
            "            for(int i = 0; i < PN; ++i)",
            "                os << o.v[i] << ' ';",
            "            return os;",
            "        }",
            "    };",
            "    constexpr Z base = Z::getBase();",
            "    vector<Z> powz(1, 1);",
            "    vector<Z> hash(string const& s) {",
            "        while(powz.size() < s.size())",
            "            powz.emplace_back(powz.back() * base);",
            "        vector<Z> h(s.size() + 1);",
            "        for(int i = 0; i < s.size(); ++i)",
            "            h[i + 1] = h[i] * base + s[i];",
            "        return h;",
            "    }",
            "    Z substrZ(vector<Z> const& h, int l, int r) {",
            "        return h[r + 1] - h[l] * powz[r - l + 1];",
            "    }",
            "    // 返回 lcp(s0[l0:], s1[l1:])",
            "    int lcp(vector<Z> const& h0, vector<Z> const& h1, int l0, int l1) {",
            "        assert(h0.size() > 1 and h1.size() > 1);",
            "        int l = 0, r = min(h0.size() - 2 - l0, h1.size() - 2 - l1), ans = -1;",
            "        while(l <= r) {",
            "            int mid = (l + r) / 2;",
            "            if(substrZ(h0, l0, l0 + mid) == substrZ(h1, l1, l1 + mid)) {",
            "                ans = mid;",
            "                l = mid + 1;",
            "            } else r = mid - 1;",
            "        }",
            "        return ans + 1;",
            "    }",
            "}// namespace str",
            "using str::Z;",
        ],
    },
    "SparseTable": {
        "prefix": "#SparseTable ST表",
        "description": "",
        "body": [
            "template<typename Int>",
            "struct SparseTable {",
            "    vector<Int> a;",
            "    function<bool(Int,Int)> better;",
            "    vector<vector<int>> f;",
            "    SparseTable(const vector<Int>& a, function<bool(Int,Int)> better)",
            "    : a(a), better(better), f(a.size(),vector<int>(__lg(a.size())+1)) {",
            "        int n=a.size(), lg=__lg(n);",
            "        for(int i=0; i<n; ++i)",
            "            f[i][0]=i;",
            "        for (int k=1; k<=lg; ++k)",
            "            for (int i=0; i+(1<<k)-1<n; ++i) {",
            "                int l=f[i][k-1],r=f[i+(1<<(k-1))][k-1];",
            "                f[i][k]=(better(a[l],a[r])?l:r);",
            "            }",
            "    }",
            "    int queryIndex(int l,int r) {",
            "        int k=__lg(r-l+1);",
            "        int i=f[l][k],j=f[r-(1<<k)+1][k];",
            "        return better(a[i],a[j])?i:j;",
            "    }",
            "    Int queryValue(int l,int r) {",
            "        return a[queryIndex(l,r)];",
            "    }",
            "};",
        ],
    },
    "oo in out": {
        "prefix": "#freopen文件输入输出",
        "description": "",
        "body": [
            "#ifdef YJL",
            "    freopen(\"oo.in\", \"r\", stdin);",
            "    freopen(\"oo.out\", \"w\", stdout);",
            "#endif",
        ],
    },
    "cppFile": {
        "prefix": "#cpp-starter",
        "description": "",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "int main() {",
            "    $0",
            "    return 0;",
            "}",
        ],
    },
    "": {
        "prefix": "",
        "description": "",
        "body": [],
    },
}