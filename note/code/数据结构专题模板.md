# 数据结构专题模板
- [数据结构专题模板](#数据结构专题模板)
- [并查集](#并查集)
- [树状数组与线段树](#树状数组与线段树)
- [李超线段树](#李超线段树)
- [单调栈维护凸包](#单调栈维护凸包)
- [动态开点线段树](#动态开点线段树)
- [Splay区间翻转](#splay区间翻转)
- [ST表](#st表)
- [LCA](#lca)
- [分块](#分块)
- [莫队](#莫队)
  - [普通莫队](#普通莫队)
  - [回滚莫队](#回滚莫队)
  - [带修莫队](#带修莫队)
- [字典树Trie](#字典树trie)
- [CDQ分治](#cdq分治)
- [整体二分](#整体二分)
- [树链剖分](#树链剖分)
- [笛卡尔树](#笛卡尔树)
- [珂朵莉树](#珂朵莉树)
- [可撤销数据结构](#可撤销数据结构)
- [手写不定长bitset](#手写不定长bitset)

# 并查集
普通并查集
```cpp
struct Dsu {
    vector<int> fa, sz;
    Dsu(int n): fa(n),sz(n,1) {
        iota(fa.begin(), fa.end(), 0);
    }
    bool unite(int x, int y) {
        x=get(x), y=get(y);
        if(x==y) return false;
        fa[x]=y;
        sz[y]+=sz[x];
        return true;
    }
    int get(int x) {
        return fa[x]==x ? x: fa[x]=get(fa[x]);
    }
    int size(int x) {
        return sz[get(x)];
    }
};
```

可撤销并查集
```cpp
struct DSU {
    vector<int> fa,sz,rank;
    stack<pair<int,int>>st;
    DSU(int n): fa(n),sz(n,1),rank(n) {
        iota(fa.begin(),fa.end(),0);
    }
    int get(int x)const {
        while(x!=fa[x])
            x=fa[x];
        return x;
    }
    void unite(int x, int y) {
        x=get(x), y=get(y);
        if(x==y) {
            st.push({-1,-1});
            return;
        }
        if(rank[x]>rank[y])
            swap(x,y);
        fa[x]=y;
        sz[y]+=sz[x];
        st.push({x,0});
        if(rank[x]==rank[y]) {
            rank[y]++;
            st.top().second=1;
        }
    }
    void rollback() {// undo last unite()
        auto v=st.top();
        st.pop();
        if(v.first==-1)
            return;
        int x=v.first, y=fa[x];
        rank[y]-=v.second;
        sz[y]-=sz[x];
        fa[x]=x;
    }
};
```

带权并查集
```cpp
struct DSU {
    vector<int> fa, d;
    DSU(int n):fa(n),d(n) {
        iota(fa.begin(), fa.end(), 0);
    }
    void unite(int x, int y, int z) {// x <--z-- y
        int fx=get(x), fy=get(y);
        if(fx!=fy) fa[fx]=fy, d[fx]=z+d[y]-d[x];
    }
    int get(int x) {
        if(fa[x]==x) return x;
        int oldfa=fa[x];
        fa[x]=get(oldfa);
        d[x]+=d[oldfa];
        return fa[x];
    }
    int dist(int x, int y) {
        int fx=get(x);
        int fy=get(y);
        assert(fx==fy);
        return d[x]-d[y];
    }
    bool connected(int x,int y) {
        return get(x)==get(y);
    }
};
```

并查集加速遍历
```cpp
struct DSU {
    int n;
    vector<int> vis,pre,nxt;
    DSU(int n): n(n),vis(n),pre(n),nxt(n) {
        iota(pre.begin(),pre.end(),-1);
        iota(nxt.begin(),nxt.end(),1);
    }
    int next(int i) {
        if(nxt[i]>=n)
            return n;
        if(vis[nxt[i]])
            nxt[i]=this->next(nxt[i]);
        return nxt[i];
    }
    int prev(int i) {
        if(pre[i]<0)
            return -1;
        if(vis[pre[i]])
            pre[i]=this->prev(pre[i]);
        return pre[i];
    }
    void set(int i) {
        vis[i]=1;
    }
    int beginToRight(int i) {
        while(i<n && vis[i])
            i=this->next(i);
        return i;
    }
    int beginToLeft(int i) {
        while(i>=0 && vis[i])
            i=this->prev(i);
        return i;
    }
};
```

# 树状数组与线段树
树状数组
```cpp
template<class T>
struct Bit {// index-0
    int n;
    vector<T> sum;
    Bit(int n): n(n), sum(n) {}
    void change(int p, T x) {
        for(++p; p<=n; p+=p&-p) sum[p-1]+=x;
    }
    T query(int p) {
        T res=0;
        for(++p; p>0; p-=p&-p) res+=sum[p-1];
        return res;
    }
    T query(int l, int r) {
        return query(r)-query(l-1);
    }
};
```

[树上二分](https://www.acwing.com/problem/content/submission/code_detail/25828602/)
```cpp
int kth(int k) {// first p, query(0,p)>=k
    int cur=0,p=0;
    for(int i=__lg(n); i>=0; --i)
        if(p+(1<<i)<=n && cur+sum[p+(1<<i)-1]<k) {
            cur+=sum[p+(1<<i)-1];
            p+=1<<i;
        }
    return p;
}
```

二维树状数组（区间修改，区间查询）
```cpp
struct BIT_2D {
    using T=long long;
    int n, m;
    vector<vector<T>> sum[4];
    BIT_2D(int _n, int _m):n(_n), m(_m) {
        for (int i=0; i<4; ++i) sum[i].assign(n+1, vector<T>(m+1, 0));
    }
    void add(int x, int y, T val) {
        for (int i=x; i<=n; i+=i&-i) {
            for (int j=y; j<=m; j+=j&-j) {
                sum[0][i][j]+=val;
                sum[1][i][j]+=val*x;
                sum[2][i][j]+=val*y;
                sum[3][i][j]+=val*x*y;
            }
        }
    }
    void range_add(int x1, int y1, int x2, int y2, T x) {
        //左上角为(x1,y1)右下角为(x2,y2)的矩阵全部加上x
        add(x1, y1, x);
        add(x1, y2+1, -x);
        add(x2+1, y1, -x);
        add(x2+1, y2+1, x);
    }
    T ask(int x, int y) {//查询左上角为(1,1)右下角为(x,y)的矩阵和
        T res[4]= {};
        for (int i=x; i>0; i-=i&-i)
            for (int j=y; j>0; j-=j&-j)
                for (int k=0; k<4; ++k)
                    res[k]+=sum[k][i][j];
        return (x+1)*(y+1)*res[0]-(y+1)*res[1]-(x+1)*res[2]+res[3];
    }
    T range_ask(int x1, int y1, int x2, int y2) {
        //查询左上角为(x1,y1)右下角为(x2,y2)的矩阵和
        return ask(x2, y2)-ask(x1-1, y2)-ask(x2, y1-1)+ask(x1-1, y1-1);
    }
};
```

线段树Tag,Data版本
```cpp
struct Tag {
    ll a,b;
    void init() {
        a=1,b=0;
    }
    void unite(const Tag &val) {
        a=a*val.a, b=b*val.a+val.b;
    }
};
struct Data {
    ll x,x2;
    // init(l,args...)
    template<class T>
    void init(int i,const T& a) {
        x=a[i],x2=1ll*a[i]*a[i];
    }
    void add(const Tag &val,int l,int r) {
        if(val.a!=1||val.b!=0) {
            x2=val.a*val.a*x2+2*val.a*val.b*x+(r-l+1)*val.b*val.b;
            x=val.a*x+(r-l+1)*val.b;
        }
    }
    friend Data operator+(const Data &lhs,const Data & rhs) {
        Data re;
        re.x=lhs.x+rhs.x;
        re.x2=lhs.x2+rhs.x2;
        return re;
    }
};
struct Segtree {
    #define u1 (u<<1)
    #define u2 (u<<1|1)
    vector<Data> tr;
    vector<Tag> lz;
    int Lpoint,Rpoint;
    template<class ...T>
    Segtree(int L,int R,const T&...args):Lpoint(L),Rpoint(R)
    ,tr(4<<__lg(R-L+1)),lz(tr.size()) {// a[L~R]建树
        build(1,L,R,args...);
    }
    template<class ...T>
    void build(int u,int l,int r,const T&...args) {
        lz[u].init();
        if(l==r) return tr[u].init(l,args...);
        int mid=(l+r)>>1;
        build(u1,l,mid,args...);
        build(u2,mid+1,r,args...);
        tr[u]=tr[u1]+tr[u2];
    }
    void push_lazy(int u,int l,int r) {
        tr[u].add(lz[u],l,r);
        if(l!=r) lz[u1].unite(lz[u]),lz[u2].unite(lz[u]);
        lz[u].init();
    }
    void change(int l,int r,const Tag &val) {
        if(Lpoint<=l&&l<=r&&r<=Rpoint)
            change(1,Lpoint,Rpoint,l,r,val);
    }
    void change(int u,int l,int r,int ql,int qr,const Tag &val) {
        push_lazy(u,l,r);
        if(l==ql&&r==qr) lz[u]=val;
        else {
            int mid=(l+r)>>1;
            if(qr<=mid) change(u1,l,mid,ql,qr,val);
            else if(ql>mid) change(u2,mid+1,r,ql,qr,val);
            else change(u1,l,mid,ql,mid,val),change(u2,mid+1,r,mid+1,qr,val);
            push_lazy(u1,l,mid),push_lazy(u2,mid+1,r);
            tr[u]=tr[u1]+tr[u2];
        }
    }
    Data query(int l,int r) {
        return query(1,Lpoint,Rpoint,l,r);
    }
    Data query(int u,int l,int r,int ql,int qr) {
        push_lazy(u,l,r);
        if(l==ql&&r==qr) return tr[u];
        int mid=(l+r)>>1;
        if(qr<=mid) return query(u1,l,mid,ql,qr);
        if(ql>mid) return query(u2,mid+1,r,ql,qr);
        return query(u1,l,mid,ql,mid)+query(u2,mid+1,r,mid+1,qr);
    }
    #undef u1
    #undef u2
};
```

树上二分
```cpp
// 返回 check 成功的区间长度
template<class Func>
int lfind(int u, int l, int r, int ql, int qr, Func const& chk) {
    if(l == ql and r == qr) {
        if(chk(tr[u])) return r-l+1;
        if(l == r) return 0;
    }
    int mid = (l + r) / 2;
    if (qr <= mid) return lfind(u1, l, mid, ql, qr, chk);
    if (ql > mid) return lfind(u2, mid+1, r, ql, qr, chk);
    int len = lfind(u1, l, mid, ql, mid, chk);
    if(len == mid-ql+1) len += lfind(u2, mid+1, r, mid+1, qr, chk);
    return len;
}
template<class Func>
int rfind(int u, int l, int r, int ql, int qr, Func const& chk) {
    if(l == ql and r == qr) {
        if(chk(tr[u])) return r-l+1;
        if(l == r) return 0;
    }
    int mid = (l + r) / 2;
    if (qr <= mid) return rfind(u1, l, mid, ql, qr, chk);
    if (ql > mid) return rfind(u2, mid+1, r, ql, qr, chk);
    int len = rfind(u2, mid+1, r, mid+1, qr, chk);
    if(len == qr-mid) len += rfind(u1, l, mid, ql, mid, chk);
    return len;
}
```

# 李超线段树
```cpp
template<class T, bool MAX=1>
struct Lichao_segtree {
    #define u1 u<<1,l,mid
    #define u2 u<<1|1,mid+1,r
    const T INF=T(1)<<(sizeof(T)*8-2);
    static constexpr double EPS=1e-6;
    struct Line {
        T k, b;
        Line() {}
        Line(T k, T b): k(k), b(b) {}
        T get(T x) const{
            return k*x+b;
        }
    };
    vector<Line> line;
    vector<int> vis;
    int ver, Lp, Rp;
    Lichao_segtree(int l, int r): ver(1), Lp(l), Rp(r), 
        line((r-l+1)*4),vis((r-l+1)*4) {}
    void clear() {
        ver++;
    }
    void add_line(T k, T b) {
        add_segment(Lp, Rp, k, b);
    }
    void add_segment(int l, int r, T k, T b) {
        add_segment(1, Lp, Rp, l, r, MAX? Line(k, b):Line(-k, -b));
    }
    void add_segment(int u,int l,int r,int ql,int qr,const Line& val) {
        int mid=(l+r)>>1;
        if (l==ql&&r==qr) {
            if (vis[u]!=ver) {
                line[u]=val, vis[u]=ver;
                return;
            }
            T l0=val.get(l), r0=val.get(r);
            T l1=line[u].get(l), r1=line[u].get(r);
            if (l1-l0>-EPS && r1-r0>-EPS ) return;
            if (l0-l1>EPS && r0-r1>EPS ) {
                line[u]=val;
                return;
            }
            T cross=(line[u].b-val.b)/(val.k-line[u].k);
            if (cross<=mid) {
                if (val.k-line[u].k<-EPS) add_segment(u1, l, mid, val);
                else add_segment(u1, l, mid, line[u]), line[u]=val;
            } else {
                if (val.k-line[u].k>EPS) add_segment(u2, mid+1, r, val);
                else add_segment(u2, mid+1, r, line[u]), line[u]=val;
            }
            return;
        }
        if (qr<=mid) add_segment(u1, ql, qr, val);
        else if (ql>mid) add_segment(u2, ql, qr, val);
        else add_segment(u1, ql, mid, val), 
            add_segment(u2, mid+1, qr, val);
    }
    T query(int x) {
        return query(1, Lp, Rp, x) * (MAX?1:-1);
    }
    T query(int u, int l, int r, int x) {
        T res=(vis[u]==ver? line[u].get(x): -INF);
        if (l==r) return res;
        int mid=(l+r)>>1;
        return max(res, x<=mid?query(u1, x):query(u2, x));
    }
};
```

# 单调栈维护凸包
- 如果先插入一系列**单调递增** (递减) 的直线，再查询一系列**单调递减** (递增) 的x坐标，可以用单调栈O(n)的解决
- 也可以再插入直线后，任意顺序每次logn二分查询
- [板子测试](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=64187007)
- [板子测试2，凸包斜率优化](https://www.luogu.com.cn/record/127444522)
```cpp
struct Line {
    ll k, b;
    ll get(ll x)const { return k*x+b; }
    friend ostream& operator<<(ostream& os,Line a) {
        return os<<"("<<a.k<<","<<a.b<<")";
    }
};
template<bool isMAX>
struct Coll {
    vector<Line> stk;
    vector<ll> pos;
    Coll() {}
    Coll(const vector<pair<ll,ll>>& alls) { ins(alls); }
    void ins(ll k, ll b) {
        if (stk.size() && stk.back().k == k) {
            if constexpr (isMAX) { if(stk.back().b>=b) return; }// MAX
            else { if(stk.back().b<=b) return; }
            stk.pop_back(), pos.pop_back();
        }
        while(true) {
            // discard ceil() facing float number
            ll cross = max<ll>(stk.size() ? ceil(1.l*(stk.back().b-b)/(k-stk.back().k)) : 0, 0);
            if(stk.size()>1 && cross<=pos.back()) {
                stk.pop_back(), pos.pop_back();
            }else {
                stk.push_back({k,b}), pos.push_back(cross);
                break;
            }
        }
    }
    void ins(vector<pair<ll,ll>> alls) {
        if constexpr (isMAX) sort(alls.begin(),alls.end());// MAX
        else sort(alls.rbegin(), alls.rend());
        for(auto [k,b]:alls) ins(k,b);
    }
    ll query(ll x) {
        while (stk.size()>1 && x<pos.back())
            stk.pop_back(), pos.pop_back();
        return stk.back().get(x);
    }
    ll queryByBinary(ll x) {
        int i=upper_bound(pos.begin()+1,pos.end(),x)-pos.begin()-1;
        return stk[i].get(x);
    }
};
vector<ll> pos_t;
#define addP(c) \
{ int sz = pos_t.size(); pos_t.insert(pos_t.end(), c.pos.begin(), c.pos.end()); \
inplace_merge(pos_t.begin(), pos_t.begin()+sz, pos_t.end()); }
```

# 动态开点线段树
[参考HEltim7](https://github.com/HEltim7/cplib/blob/master/Templates/ds/mergeable_segment_tree.cpp)
[abc线段树合并例题](https://atcoder.jp/contests/abc359/submissions/54892589)
[牛客主席树例题](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=69857774)
以下代码包括线段树合并的功能
```cpp
namespace sgt {
struct Node {
    int lc, rc;
    int cnt;
    ll sum;
    void pushup(Node const& lc, Node const& rc) {
        cnt = lc.cnt + rc.cnt;
        sum = lc.sum + rc.sum;
    }
    // change(i, args...)
    void change(int i) {
        cnt++;
        sum += i;
    }
    // mergeLeaf(o, args...)
    void mergeLeaf(Node const& o, ll w) {}
};

vector<Node> tr;
int L, R, idx;

// op_num : change 总次数
void init(int op_num, int l, int r) {
    tr.resize(op_num * (__lg(r-l+1) + 2) + 10, {});
    L = l, R = r, idx = 0;
}

template<class ...T>
void change(int &u, int l, int r, int p, T const&...args) {
    assert(++idx < tr.size());
    tr[idx] = tr[u];
    u = idx;
    if(l == r) {
        tr[u].change(l, args...);
        return;
    }
    int mid = (l + r) / 2;
    if(p <= mid) change(tr[u].lc, l, mid, p, args...);
    else change(tr[u].rc, mid+1, r, p, args...);
    tr[u].pushup(tr[tr[u].lc], tr[tr[u].rc]);
}
template<class ...T>
void change(int &u, int p, T const&...args) {
    assert(L <= p and p <= R);
    change(u, L, R, p, args...);
}

template<class ...T>
void merge(int &u, int v,  int l, int r, T const&...args) {
    if(!u or !v) u = u | v;
    else if(l == r) {
        tr[u].mergeLeaf(tr[v], args...);
    } else {
        int mid = (l + r) / 2;
        merge(tr[u].lc, tr[v].lc, l, mid, args...);
        merge(tr[u].rc, tr[v].rc, mid+1, r, args...);
        tr[u].pushup(tr[tr[u].lc], tr[tr[u].rc]);
    }
}
template<class ...T>
void merge(int &u, int v, T const&... with_args) {
    merge(u, v, L, R, with_args...);
}

// auto query(int u, int l, int r, int x, int y) {
//     if(!u or l > y or r < x) return 0ll;
//     if(l>=x and r<=y) return tr[u].ans;
//     int mid = (l + r) / 2;
//     return query(tr[u].lc, l, mid, x, y) + query(tr[u].rc, mid+1, r, x, y);
// }
// auto query(int u, int l, int r) {
//     return query(u, L, R, l, r);
// }

// 在 tr[u] - tr[v] 上二分: sum<=w 最多多少个数
auto binaryS(int u, int v, int l, int r, ll w) {
    if(l == r) return min<ll>(tr[u].cnt - tr[v].cnt, w / l);
    int mid = (l + r) / 2;
    auto tmp = w - (tr[tr[u].lc].sum - tr[tr[v].lc].sum);
    if(tmp <= 0) return binaryS(tr[u].lc, tr[v].lc, l, mid, w);
    return binaryS(tr[u].rc, tr[v].rc, mid+1, r, tmp)
        + tr[tr[u].lc].cnt - tr[tr[v].lc].cnt;
}
auto binaryS(int u, int v, ll w) {
    return binaryS(u, v, L, R, w);
}

}// namespace sgt
```

线段树分裂参考代码
```cpp
pair<int,int> split(int u,int l,int r,int p) {
    if(r<p) return {u,0};
    if(l>=p) return {0,u};
    pushdn(u);
    int v=new_node();
    int mid=(l+r)/2;
    auto [a,b]=split(lch, l, mid, p);
    auto [c,d]=split(rch, mid+1, r, p);
    tr[u].lc=a,tr[u].rc=c;
    tr[v].lc=b,tr[v].rc=d;
    pushup(u),pushup(v);
    return {u,v};
}
pair<int,int> split(int u,int p) { return split(u,L,R,p); }
int extract(int &u,int l,int r,int x,int y) {
    auto [a,b]=split(u, l, r, x);
    auto [c,d]=split(b, l, r, y+1);
    merge(a, d, l, r);
    return u=a,c;
}
int extract(int &u,int l,int r) { return extract(u,L,R,l,r); }
```

# Splay区间翻转
也可以尝试用 $rope$
```cpp
struct Splay {
    struct Node {
        int key, siz;
        int rev;
        int fa, ch[2];
    };
    int n, id, root;
    vector<Node> t;
    Splay(int n) : n(n), id(), root(), t(n+10) {// [1,n]建树
        root = build(0, n+1);
    }
    void pushup(int u) {
        t[u].siz = 1 + t[t[u].ch[0]].siz + t[t[u].ch[1]].siz;
    }
    void pushdown(int u) {
        if (t[u].rev) {
            swap(t[u].ch[0], t[u].ch[1]);
            t[t[u].ch[0]].rev^=1, t[t[u].ch[1]].rev ^= 1;
            t[u].rev = 0;
        }
    }
    int build(int l, int r) {
        int u = ++id;
        int mid = (l+r)/2;
        t[id].key = mid;
        t[id].siz = 1;
        if (l<mid) t[u].ch[0] = build(l, mid-1);
        if (mid<r) t[u].ch[1] = build(mid+1, r);
        t[t[u].ch[0]].fa = t[t[u].ch[1]].fa = u;
        pushup(u);
        return u;
    }
    void reverse(int l, int r) {// 翻转[l,r]
        l = get_kth(l), r = get_kth(r+2);
        splay(l), splay(r, l);
        t[t[r].ch[0]].rev ^= 1;
    }
    void rotate(int u) {
        int fa = t[u].fa, gfa = t[fa].fa;
        t[gfa].ch[t[gfa].ch[1] == fa] = u, t[u].fa = gfa;
        int k = (t[fa].ch[1] == u);
        t[fa].ch[k] = t[u].ch[k^1], t[t[u].ch[k^1]].fa = fa;
        t[u].ch[k^1] = fa, t[fa].fa = u;
        pushup(fa), pushup(u);
    }
    void splay(int u, int s=0) {
        while (t[u].fa != s) {
            int fa = t[u].fa, gfa = t[fa].fa;
            if (gfa != s) {
                if ((t[fa].ch[1] == u) ^ (t[gfa].ch[1] == fa)) rotate(u);
                else rotate(fa);
            }
            rotate(u);
        }
        if (!s) root = u;
    }
    int get_kth(int Rank) {
        int u = root;
        while (u) {
            pushdown(u);
            if (t[t[u].ch[0]].siz >= Rank) u = t[u].ch[0];
            else if (t[t[u].ch[0]].siz+1 >= Rank) return u;
            else Rank -= t[t[u].ch[0]].siz+1, u = t[u].ch[1];
        }
        return 0;
    }
    void midOrder(int u,vector<int>& a) {// 遍历[1,n]
        if (!u) return;
        pushdown(u);
        midOrder(t[u].ch[0], a);
        if (t[u].key >= 1 and t[u].key <= n) a.push_back(t[u].key);
        midOrder(t[u].ch[1],a);
    }
};
```

# ST表
```cpp
template<typename Int>
struct SparseTable {
    vector<vector<int>> f;
    vector<Int> a;
    function<bool(Int,Int)> better;
    SparseTable(const vector<Int>& a, function<bool(Int,Int)> better)
    : a(a), better(better), f(a.size(),vector<int>(__lg(a.size())+1)) {
        int n=a.size(), lg=__lg(n);
        for(int i=0; i<n; ++i)
            f[i][0]=i;
        for (int k=1; k<=lg; ++k)
            for (int i=0; i+(1<<k)-1<n; ++i) {
                int l=f[i][k-1],r=f[i+(1<<(k-1))][k-1];
                f[i][k]=(better(a[l],a[r])?l:r);
            }
    }
    int queryIndex(int l,int r) {
        int k=__lg(r-l+1);
        int i=f[l][k],j=f[r-(1<<k)+1][k];
        return better(a[i],a[j])?i:j;
    }
    Int queryValue(int l,int r) {
        return a[queryIndex(l,r)];
    }
};
```

# LCA
$O(n*logn)$预处理倍增数组，$O(logn)$在线询问，可以附带维护信息
```cpp
struct LcaTree {
    int n;
    const int LOG;
    vector<vector<int>> g,f;
    vector<int> deep;
    LcaTree(int n): n(n), LOG(__lg(n)), g(n)
    ,f(n,vector<int>(LOG+1,-1)), deep(n,-1) {}
    void addEdge(int u,int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    void dfs(int u, int fa) {
        f[u][0]=fa;
        // w[u][0]=Node(val[u]);
        for(int j=1; (1<<j)<=deep[u]; ++j) {
            f[u][j]=f[ f[u][j-1] ][j-1];
            // w[u][j]=w[u][j-1]+w[f[u][j-1]][j-1];
        }
        for(int v:g[u]) {
            if(v==fa) continue;
            deep[v]=deep[u]+1;
            dfs(v,u);
        }
    }
    void initLca(int root=0) {// 森林需要调用多次
        deep[root]=0;
        dfs(root,-1);
    }
    int lca(int u, int v) {
        if(deep[u]<deep[v]) swap(u, v);
        int h=deep[u]-deep[v];
        for(int i=LOG; i>=0; --i)
            if(h>>i&1) u=f[u][i];
        if(u==v) return u;
        // if(!deep[u]) return -1;// u,v不在一颗树上
        for(int i=LOG; i>=0; --i)
            if((1<<i)<=deep[u] && f[u][i]!=f[v][i])
                u=f[u][i], v=f[v][i];
        return f[u][0];
    }
    int kth(int u, int k) {
        assert(k<=deep[u]);
        for(int i=LOG; i>=0; --i)
            if(k>>i&1) u=f[u][i];
        return u;
    }
    int dist(int u,int v) {
        return deep[u]+deep[v]-2*deep[lca(u,v)];
    }
    // int calc(int u,int v) {
    //     int fa=lca(u,v);
    //     int ans=w[fa][0];
    //     int du=deep[u]-deep[fa];
    //     int dv=deep[v]-deep[fa];
    //     for(int i=LOG; i>=0; --i)
    //         if(du>>i&1)
    //             ans+=w[u][i], u=f[u][i];
    //     for(int i=LOG; i>=0; --i)
    //         if(dv>>i&1)
    //             ans+=w[v][i], v=f[v][i];
    //     return ans;
    // }
};
```

利用欧拉序列将求$LCA$转化为纯 $RMQ$ 问题，$O(n*logn)$预处理倍增数组，$O(1)$在线询问  
```cpp
struct EulerLca {// index-1
    static constexpr int N = 5e5 * 2 + 10, LOG = __lg(N);
    int euler[N],id[N],cnt;// cnt=2*n-1
    vector<int> g[N];
    void addEdge(int u,int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    void dfs(int u,int fa=-1) {
        euler[id[u]=++cnt]=u;
        for(int v:g[u]) {
            if(v==fa) continue;
            dfs(v,u);
            euler[++cnt]=u;
        }
    }
    int f[N][LOG+1];
    void init(int rt) {
        dfs(rt);
        for(int i=1; i<=cnt; ++i)
            f[i][0]=id[euler[i]];
        for(int k=1; k<=LOG; ++k)
            for(int i=1; i+(1<<k)-1<=cnt; ++i)
                f[i][k]=min(f[i][k-1],f[i+(1<<k-1)][k-1]);
    }
    int lca(int u,int v) {
        int l=id[u],r=id[v];
        if(l>r) swap(l,r);
        int k=__lg(r-l+1);
        return euler[min(f[l][k],f[r-(1<<k)+1][k])];
    }
} el;
```

tarjan离线$O(n+q)$求$LCA$,可能常数大
```cpp
struct TarjanLca {
    static constexpr int N = 5e5 + 10;// 节点数
    static constexpr int QN = 1e6 + 10;// 询问次数
    struct EDGE {
        int t,next;
    } edge[N*2+QN*2];
    int en, head[N], headQ[N];
    int qry[QN][2], qn, result[QN];// [0,qn)
    bool vis[N];
    int pr[N];// 与求lca无关的变量
    TarjanLca() {
        memset(head,-1,sizeof head);
        memset(headQ,-1,sizeof headQ);
        iota(Fa,Fa+N,0);
    }
    void addEdge(int x,int y) {
        edge[en]={y,head[x]}, head[x]=en++;
        edge[en]={x,head[y]}, head[y]=en++;
    }
    void addQuery(int u,int v) {
        qry[qn][0]=u;
        qry[qn][1]=v;
        edge[en]={qn,headQ[u]}, headQ[u]=en++;
        edge[en]={qn,headQ[v]}, headQ[v]=en++;
        ++qn;
    }
    void dfsLca(int u,int fa=-1) {
        pr[u]=fa;
        vis[u]=true;
        for(int k=headQ[u]; ~k; k=edge[k].next) {
            int i=edge[k].t;
            int v=qry[i][0]^qry[i][1]^u;
            if(vis[v]) result[i]=getF(v);
        }
        for(int i=head[u]; ~i; i=edge[i].next) {
            int v=edge[i].t;
            if(vis[v]) continue;
            dfsLca(v,u);
            Fa[v]=u;
        }
    }
private:
    int Fa[N];
    int getF(int u) {
        return Fa[u]==u?u: Fa[u]=getF(Fa[u]);
    }
} tl;
```

# 分块
```cpp
const int N=2e5+10, Block=sqrt(N)+1;
ll n, q, a[N], val[Block+10], lazy[Block+10];
int L[Block+10], R[Block+10], siz[Block+10], belong[N];
void makeblock(int n) { //[1,n]分块
    for (int i=1; i<=n; ++i) belong[i]=(i-1)/Block+1;
    for (int i=1; i<=belong[n]; ++i) {
        L[i]=(i-1)*Block+1;
        R[i]=i*Block;
        siz[i]=Block;
    }
    R[belong[n]]=n, siz[belong[n]]=R[belong[n]]-L[belong[n]]+1;
    for (int i=1; i<=n; ++i) val[belong[i]]+=a[i];
}
void change(int l, int r, ll delta) {
    if (belong[l]==belong[r]) {
        for (int i=l; i<=r; ++i) a[i]+=delta, val[belong[l]]+=delta;
        return;
    }
    for (int k=belong[l]+1; k<belong[r]; ++k)
        val[k]+=delta*siz[k], lazy[k]+=delta;
    for (int i=l; i<=R[belong[l]]; ++i) a[i]+=delta, val[belong[i]]+=delta;
    for (int i=L[belong[r]]; i<=r; ++i) a[i]+=delta, val[belong[i]]+=delta;
}
ll query(int l, int r) {
    ll res=0;
    if (belong[l]==belong[r]) {
        for (int i=l; i<=r; ++i) res+=a[i];
        return res+lazy[belong[l]]*(r-l+1);
    }
    for (int k=belong[l]+1; k<belong[r]; ++k) res+=val[k];
    for (int i=l; i<=R[belong[l]]; ++i) res+=a[i];
    for (int i=L[belong[r]]; i<=r; ++i) res+=a[i];
    return res+lazy[belong[l]]*(R[belong[l]]-l+1)
           +lazy[belong[r]]*(r-L[belong[r]]+1);
}
```

# 莫队
## 普通莫队
```cpp
struct Node { int l, r, id; };
vector<Node> pro;
int l=1, r=0;// index-1
int cnt[N];
ll cur=0;
ll ans[N];
void add(int p) {
    int &x=cnt[a[p]];
    cur-=1ll*x*x;
    x++;
    cur+=1ll*x*x;
}
void del(int p) {
    int &x=cnt[a[p]];
    cur-=1ll*x*x;
    x--;
    cur+=1ll*x*x;
}
void arrive(int ql, int qr) {
    while(ql<l) add(--l);
    while(r<qr) add(++r);
    while(l<ql) del(l++);
    while(qr<r) del(r--);
}
void solve() {
    int B=max<int>(1,n/sqrt(pro.size()+.5));// O(nsqrt(m))
    sort(pro.begin(), pro.end(), [&](const Node& x, const Node& y) {
        if(x.l/B!=y.l/B) return x.l<y.l;
        if(x.l/B%2==0) return x.r<y.r;
        return x.r>y.r;
    });
    for(auto [l,r,id]:pro) {
        arrive(l,r);
        ans[id]=cur;
    }
}
```

## 回滚莫队
$O(n\sqrt(n))$
```cpp
struct Qu { int l,r,i; };
vector<Qu> qry;
int ans[5050],cur;
int nxt[N],pre[N];
vector<pair<int,int>> alls;
void rebuild(int L,int R) {
    for(int i=L; i<=R; ++i)
        alls.emplace_back(a[i],i);
    sort(alls.end()-(R-L+1),alls.end());
    inplace_merge(alls.begin(),alls.end()-(R-L+1),alls.end());
    int last=0;
    cur=0;
    for(const auto& [val,i]:alls) {
        cur=(cur+1ll*lga[last]*a[i])%PHI;
        nxt[last]=i;
        pre[i]=last;
        last=i;
    }
    nxt[alls.rbegin()->second]=0;
}
void del(int i) {
    cur=(cur-1ll*lga[pre[i]]*a[i]%PHI+PHI)%PHI;
    cur=(cur-1ll*lga[i]*a[nxt[i]]%PHI+PHI)%PHI;
    cur=(cur+1ll*lga[pre[i]]*a[nxt[i]])%PHI;
    nxt[pre[i]]=nxt[i];
    pre[nxt[i]]=pre[i];
}
void add(int i) {// 撤销操作
    nxt[pre[i]]=i; 
    pre[nxt[i]]=i;
}
void solve() {
    int B=max<int>(1,n/sqrt(pro.size()+.5));// O(nsqrt(m))
    sort(qry.begin(),qry.end(),[&](const auto& a,const auto& b){
        if(a.l/B!=b.l/B)
            return a.l>b.l;
        return a.r>b.r;
    });
    int idx=0;
    for(int i=(n-1)/B+1; i>=1; --i) {
        int L=(i-1)*B+1, l=L;
        int R=min(n,i*B), r=n;
        rebuild(L,R);
        for( ;idx<qry.size() && qry[idx].l>=L; ++idx) {
            while(r>qry[idx].r) del(r--);
            int temp=cur;
            while(l<qry[idx].l) del(l++);
            ans[qry[idx].i]=cur;
            while(l>L) add(--l);
            cur=temp;
        }
    }
}
```

## 带修莫队
$O(n^{5/6})$
```cpp
// 问区间种类数 和 修改单点颜色
int n, m, a[N], ans[N];
int cnt[N];
struct pro {
    int id, l, r, t;
} b[N];
struct upd {
    int pos, val;
} c[N];
int bn, cn;
int l=1, r=0, t=0, nowans=0;
void add(int p) {
    if (++cnt[a[p]]==1) nowans++;
}
void del(int p) {
    if (--cnt[a[p]]==0) nowans--;
}
void arrive(int ql, int qr, int qt) {
    while (ql<l) add(--l);
    while (r<qr) add(++r);
    while (l<ql) del(l++);
    while (qr<r) del(r--);
    while (t<qt) {
        ++t;
        if (c[t].pos>=l && c[t].pos<=r) {
            del(c[t].pos);
            swap(a[c[t].pos], c[t].val);
            add(c[t].pos);
        } else swap(a[c[t].pos], c[t].val);
    }
    while (t>qt) {
        if (c[t].pos>=l && c[t].pos<=r) {
            del(c[t].pos);
            swap(a[c[t].pos], c[t].val);
            add(c[t].pos);
        } else swap(a[c[t].pos], c[t].val);
        --t;
    }
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin>>n>>m;
    for (int i=1; i<=n; ++i) cin>>a[i];
    while (m--) {
        char op;
        int ql, qr;
        cin>>op>>ql>>qr;
        if (op=='Q') ++bn, b[bn]= {bn, ql, qr, cn};
        else ++cn, c[cn]= {ql, qr};
    }
    int B=pow(n, 0.66666666666666);
    sort(b+1, b+1+bn, [&](const pro& x, const pro& y) {
        if (x.l/B!=y.l/B) return x.l/B<y.l/B;
        if (x.r/B!=y.r/B) return x.r/B<y.r/B;
        return x.t<y.t;
    });
    for (int i=1; i<=bn; ++i) {
        auto [id, ql, qr, qt]=b[i];
        arrive(ql, qr, qt);
        ans[id]=nowans;
    }
    for (int i=1; i<=bn; ++i) cout<<ans[i]<<'\n';
    return 0;
}
```

# 字典树Trie
```cpp
namespace {
    const int M=1e6+10;//所有字符串总长度
    int root=1, tot=1, ch[M][26], Path[M], End[M];
    int newnode() {
        ++tot, memset(ch[tot], 0, sizeof ch[tot]), Path[tot]=End[tot]=0;
        return tot;
    }
    void init_trie() {tot=0,root=newnode();}
    void ins(char *str) {
        int u=root;
        for (; *str; ++str) {
            int id=*str-'a';
            if (!ch[u][id]) ch[u][id]=newnode();
            u=ch[u][id];
            Path[u]++;
        }
        End[u]++;
    }
    int query(char *str) {
        int u=root;
        for (; *str; ++str) {
            int id=*str-'a';
            if (!ch[u][id]) return 0;
            u=ch[u][id];
        }
        return End[u];
    }
    int queryPre(char *str) {
        int u=root;
        for (; *str; ++str) {
            int id=*str-'a';
            if (!ch[u][id]) return 0;
            u=ch[u][id];
        }
        return Path[u];
    }
}
```

01树求最大异或
```cpp
template<class T>
struct Trie01 {
    const int m, SZ;
    vector<array<int,2>> ch;
    vector<int> cnt;
    int idx, root;
    Trie01(int n) : m(sizeof(T)*8), SZ(n*m+10), ch(SZ, array<int,2>{}), idx(2), root(1) {
        cnt.assign(SZ, 0);
    }
    void ins(T x, int v = 1) {
        int u = root;
        for(int i=m-1; i>=0; --i) {
            int w = x>>i&1;
            if(!ch[u][w]) ch[u][w] = idx++;
            cnt[u = ch[u][w]] += v;
        }
    }
    T xorMax(T x) {// return max(x^y)
        int u = root;
        T ans = 0;
        for(int i=m-1; i>=0; --i) {
            int w = x>>i&1;
            if(cnt[ch[u][w^1]]) u = ch[u][w^1], ans += (T(1)<<i);
            else u = ch[u][w];
            if(!u) break;
        }
        return ans;
    }
};
```

可持久化01树
```cpp
namespace tri {
    using T = int;
    constexpr int m = sizeof(T)*8;
    vector<array<int,2>> ch;
    vector<int> cnt;
    int idx;
    void init(int n) {
        const int SZ = n * (m + 1) + 10;
        ch.assign(SZ, array<int,2>{});
        cnt.assign(SZ, 0);
        idx = 1;
    }
    int newNode(int from) {
        ch[idx] = ch[from];
        cnt[idx] = cnt[from];
        idx++;
        return idx-1;
    }
    int ins(int u, T x, int v = 1) {
        int root = u = newNode(u);
        for(int i=m-1; i>=0; --i) {
            int w = x>>i&1;
            ch[u][w] = newNode(ch[u][w]);
            cnt[u = ch[u][w]] += v;
        }
        return root;
    }
    // tr[u] - tr[v]
    T xorMax(int u, int v, T x) {// return max(x^y)
        T ans = 0;
        for(int i=m-1; i>=0; --i) {
            int w = x>>i&1;
            if(cnt[ch[u][w^1]] - cnt[ch[v][w^1]]) {
                ans += (T(1)<<i);
                u = ch[u][w^1];
                v = ch[v][w^1];
            }else {
                u = ch[u][w];
                v = ch[v][w];
            }
            if(!u) break;
        }
        return ans;
    }
}// namespace tri
```

# CDQ分治
[HH的项链](https://ac.nowcoder.com/acm/contest/20888/C)
```cpp
int L[N],R[N],typ[N];
int tmp[N], id[N];
int ans[N];
int cmp(int i, int j) {// main sort
    if (L[i]==L[j]&&typ[i]!=typ[j])
        return typ[i]==1;
    return L[i]<L[j];
}
void cdq(int l, int r) {
    if (l==r) return;
    int mid=(l+r)>>1;
    cdq(l, mid), cdq(mid+1, r);
    int sum=0;
    for (int k=l, i=l, j=mid+1; k<=r;) {
        if (j>r || (i<=mid && R[id[i]]<R[id[j]])) {
            if (typ[id[i]]==0) sum++;
            tmp[k++]=id[i++];
        } else {
            if (typ[id[j]]==1) ans[id[j]]+=sum;
            tmp[k++]=id[j++];
        }
    }
    copy(tmp+l, tmp+r+1, id+l);
}
```

左右都需要按cmp排序再dp转移:
[拦截导弹](https://ac.nowcoder.com/acm/problem/16810)
```cpp
int n, a[N], dp[N];
int id[21][N];//每一层排好的元素,块内有序
bool cmp(int i, int j) {
    return a[i]<a[j];
}
void MergeSort(int l, int r, int c=0) { //后序遍历记录归并树
    if (l==r) {
        id[c][l]=l;
        return;
    }
    int mid=(l+r)>>1;
    MergeSort(l, mid, c+1), MergeSort(mid+1, r, c+1);
    for (int k=l, i=l, j=mid+1; k<=r;) {
        if (j>r || (i<=mid && cmp(id[c+1][i], id[c+1][j])) )
            id[c][k++]=id[c+1][i++];
        else id[c][k++]=id[c+1][j++];
    }
}
void cdq(int l, int r, int c=0) { //中序遍历进行dp转移
    if (l==r) {
        dp[l]=max(dp[l], 1);
        return;
    }
    int mid=(l+r)>>1;
    cdq(l, mid, c+1);
    int pre=0;
    for (int k=l, i=l, j=mid+1; k<=r;) {
        if (j>r || (i<=mid && cmp(id[c+1][i], id[c+1][j])) )
            pre=max(pre, dp[id[c+1][i]]), k++, i++;
        else dp[id[c+1][j]]=max(dp[id[c+1][j]], pre+1), k++, j++;
    }
    cdq(mid+1, r, c+1);
}
```

左边按cmp排序，右边依照原顺序:
[P2497基站建设](https://www.luogu.com.cn/problem/P2497)
```cpp
int tmp[N], id[N];
bool cmp(int i, int j) {
    return r1[i]<r1[j];
}
void cdq(int l, int r) {
    if (l==r) return;
    int mid=(l+r)>>1;
    cdq(l, mid);
    init();
    for (int i=l; i<=mid; ++i) ins(r1[id[i]]);
    for (int i=r; i>mid; --i) query(x[id[i]]);
    cdq(mid+1, r);
    for (int k=l, i=l, j=mid+1; k<=r;) {
        if (j>r || (i<=mid && cmp(id[i], id[j]))) tmp[k++]=id[i++];
        else tmp[k++]=id[j++];
    }
    copy(tmp+l, tmp+r+1, id+l);
}
```

# 整体二分
```cpp
// 注意调节"修改"和"询问"两种操作的位置
struct ty {
    int x, y, k, type; //type==1表示修改，type==2表示查询
} q[N];
int ans[N];
int id[N], tmp1[N], tmp2[N];
void solve(int low, int high, int l, int r) {
    //在值域[low,high]中解决id[l~r]的问题
    if (l>r) return;
    if (low==high) {
        for (int i=l; i<=r; ++i) ans[id[i]]=low;
        return;
    }
    int mid=(low+high)>>1;
    int n1=0, n2=0;
    for (int i=l; i<=r; ++i) {
        ty& now=q[id[i]];
        if (now.type==1) { //修改
            if (now.y<=mid) {
                tr.change(now.x, now.k);
                tmp1[++n1]=id[i];
            } else tmp2[++n2]=id[i];
        } else {//询问
            int t=tr.query(now.x, now.y);
            if (now.k<=t) tmp1[++n1]=id[i];
            else now.k-=t, tmp2[++n2]=id[i];
        }
    }
    //clear
    for (int i=l; i<=r; ++i) {
        ty& now=q[id[i]];
        if (now.type==1 && now.y<=mid)
            tr.change(now.x, -now.k);
    }
    //copy
    copy(tmp1+1, tmp1+n1+1, id+l), copy(tmp2+1, tmp2+n2+1, id+l+n1);
    solve(low, mid, l, l+n1-1), solve(mid+1, high, l+n1, r);
}
```

# 树链剖分
```cpp
namespace hpd {// index-1
    static constexpr int N = 2e5 + 10;// TODO
    struct Node {
        int t,l,next;
    } edge[N*2];
    int n, en, head[N];
    int f[N], deep[N], siz[N], son[N], toEdge[N];
    int top[N], ord[N], id[N], idn;
    void initTree(int _n) {
        n = _n;
        fill_n(head+1,n,-1), en = 0;
    }
    void addEdge(int x,int y,int z=0) {
        edge[en]={y,z,head[x]};
        head[x]=en++;
        edge[en]={x,z,head[y]};
        head[y]=en++;
    }
    void dfs1(int u, int fa, int deepth) {
        f[u]=fa;
        deep[u]=deepth;
        siz[u]=1;
        son[u]=0;
        for(int i=head[u]; ~i; i=edge[i].next) {
            int v=edge[i].t;
            if(v==fa) continue;
            dfs1(v, u, deepth+1);
            toEdge[v]=i/2;
            siz[u]+=siz[v];
            if(siz[v]>siz[son[u]])
                son[u]=v;
        }
    }
    void dfs2(int u, int topp) {
        top[u]=topp;
        ord[id[u]=++idn]=u;
        if(son[u])
            dfs2(son[u], topp);
        for(int i=head[u]; ~i; i=edge[i].next) {
            int v=edge[i].t;
            if(v!=f[u]&&v!=son[u])
                dfs2(v, v);
        }
    }
    void treePartition() {
        idn=0;
        dfs1(1,0,1);
        dfs2(1,1);
    }
    vector<pair<int,int>> decompose(int x,int y,bool isEdge=false) {
        vector<pair<int,int>> q;
        while(top[x]!=top[y]) {
            if(deep[top[x]]>=deep[top[y]]) {
                q.emplace_back(id[top[x]], id[x]);
                x=f[top[x]];
            }else {
                q.emplace_back(id[top[y]], id[y]);
                y=f[top[y]];
            }
        }
        if(id[x]==id[y]&&isEdge)
            return q;
        if(id[x]<id[y]) q.emplace_back(id[x]+isEdge, id[y]);
        else q.emplace_back(id[y]+isEdge, id[x]);
        return q;
    }
    // https://ac.nowcoder.com/acm/contest/view-submission?submissionId=69946974
    // 按 s -> t 的顺序操作区间 func(l, r)
    // 其中可能有 l>r 的情况，表示这个区间是自下而上的，和 dfs序 逆向
    template<class Func>
    void solve(int s, int t, Func func) {
        vector<pair<int,int>> q;
        while(top[s]!=top[t]) {
            if(deep[top[s]]>=deep[top[t]]) {
                func(id[s], id[top[s]]);
                s = f[top[s]];
            }else {
                q.emplace_back(id[top[t]], id[t]);
                t=f[top[t]];
            }
        }
        if(id[s]<id[t]) {
            func(id[s], id[t]);
        } else {
            q.emplace_back(id[s], id[t]);
        }
        reverse(q.begin(), q.end());
        for(auto [s,t]:q) {
            func(s, t);
        }
    }
    int lca(int x,int y) {
        while(top[x]!=top[y]) {
            if(deep[top[x]]<deep[top[y]])
                swap(x,y);
            x=f[top[x]];
        }
        if(deep[x]<deep[y])
            swap(x,y);
        return y;
    }
} // namespace hpd
```

# 笛卡尔树
笛卡尔树的中序遍历是 $0 \sim n-1$，同时节点属性 $v[i]$ 还满足堆的性质。
```cpp
int root;
vector<int> lch, rch;
void build(const vector<int> &v) {// index-0
    int n = v.size(), top = 0;
    vector<int> stk(n+1);
    lch.assign(n, -1);
    rch.assign(n, -1);
    for(int i=0; i<n; ++i) {
        int k = top;
        while(k and v[stk[k]] > v[i]) k--;// 小根堆
        // while(k && v[stk[k]] < v[i]) k--;// 大根堆
        if(k) rch[stk[k]] = i;
        else root = i;
        if(k<top) lch[i] = stk[k+1];
        stk[++k] = i;
        top = k;
    }
}
```

# 珂朵莉树
相同颜色相邻，合并为同一个节点
```cpp
struct ODT {
    struct Node {
        int l;
        mutable int r, val; //[l,r)
        bool operator<(const Node &v)const {
            return l<v.l;
        }
        friend ostream& operator<<(ostream& out,const Node& v) {
            return out<<"{"<<v.l<<","<<v.r<<","<<v.val<<"}";
        }
    };
    set<Node> s;
    /// @brief 操作区间 [L,R)
    ODT(int L, int R) {
        s.insert({L-1, L, 0}); // s.begin()
        s.insert({L, R, 0});
    }
    using iter=set<Node>::iterator;
    iter split(int pos) { // 把pos所在节点拆分出来
        auto it=s.lower_bound({pos, 0, 0});
        if (it!=s.end()&&it->l==pos) return it;
        --it;
        Node u=*it;
        s.erase(it);
        s.insert({u.l, pos, u.val});
        return s.insert({pos, u.r, u.val}).first;
    }
    void upFrom(iter it) {// 将it与右邻居合并，减少节点个数
        if (it==s.begin()) ++it;
        for (iter nxt; it!=s.end() && (nxt=next(it))!=s.end()
             && nxt->val==it->val;) {
            it->r=nxt->r;
            s.erase(nxt);
        }
    }
    /// @brief 注意是 [l,r) 区间赋值
    void assign(int l, int r, int val) {
        iter itr=split(r), itl=split(l);
        s.erase(itl, itr);
        iter it=s.insert({l, r, val}).first;
        upFrom(it), upFrom(prev(it));
    }
    auto getInfo()const {
        vector<tuple<int,int,int>> v;
        for(auto it=next(s.begin()); it!=s.end(); ++it) {
            v.emplace_back(it->l, it->r, it->val);
        }
        return v;
    }
};
```

set维护覆盖区间并集长度(区间不相交，但区间相邻也不合并)
```cpp
struct ODT {
    struct Interval {
        int l,r;// [l,r]
        Interval(int l,int r):l(l),r(r) {}
        int len() const{
            return r-l+1;
        }
        bool operator<(const Interval& y) const{
            if(l^y.l)
                return l<y.l;
            return r<y.r;
        }
    };
    set<Interval> s;
    int LOW, n;
    ODT(int low):LOW(low-1),n(0) {
        s.insert(Interval(LOW,LOW));
    }
    void push(int l,int r) {
        auto it=--s.upper_bound(Interval(l,LOW));
        int nl=l,nr=r;
        if(it->r<l) ++it;
        else {
            nl=it->l, nr=max(nr,it->r);
            n-=it->len(), it=s.erase(it);
        }
        for(; it!=s.end() && it->l<=r;) {
            nr=max(nr,it->r);
            n-=it->len(), it=s.erase(it);
        }
        n+=Interval(nl,nr).len(), s.insert(Interval(nl,nr));
    }
};
```

# 可撤销数据结构
```cpp
template<class T>
struct RecoverStack {
    stack<pair<T&,T>> st;
    void assign(T& x,T y) {
        st.push({x,x});
        x=y;
    }
    /// @brief 全部撤销
    void rollBackAll() {
        while(st.size()) {
            swap(st.top().first,st.top().second);
            st.pop();
        }
    }
    void clear() {
        while(st.size())
            st.pop();
    }
    vector<int> flag;
    void setFlag() {
        flag.push_back(st.size());
    }
    /// @brief 撤销到上一个flag位置
    void rollBackFlag() {
        while(st.size()!=flag.back()) {
            swap(st.top().first,st.top().second);
            st.pop();
        }
        flag.pop_back();
    }
};
```

# 手写不定长bitset
总大小 $1e6$ 的 $01$ [背包](https://codeforces.com/contest/1856/submission/217396025)
```cpp
using uint64 = unsigned long long;
struct custom_bitset {
    vector<uint64> bits;
    int64_t b, n;
    custom_bitset(int64_t _b = 0) {
        init(_b);
    }
    void init(int64_t _b) {
        b = _b;
        n = (b + 63) / 64;
        bits.assign(n, 0);
    }
    void clear() {
        b = n = 0;
        bits.clear();
    }
    void reset() {
        bits.assign(n, 0);
    }
    // Reset all bits after `b`.
    void _clean() {
        if (b != 64 * n)
            bits.back() &= (1LLU << (b - 64 * (n - 1))) - 1;
    }
    bool get(int64_t index) const {
        return bits[index / 64] >> (index % 64) & 1;
    }
    void set(int64_t index, bool value) {
        assert(0 <= index && index < b);
        bits[index / 64] &= ~(1LLU << (index % 64));
        bits[index / 64] |= uint64(value) << (index % 64);
    }
    // Simulates `bs |= bs << shift;`
    void or_shift(int64_t shift) {
        int64_t div = shift / 64, mod = shift % 64;
        if (mod == 0) {
            for (int64_t i = n - 1; i >= div; i--)
                bits[i] |= bits[i - div];
            return;
        }
        for (int64_t i = n - 1; i >= div + 1; i--)
            bits[i] |= bits[i - (div + 1)] >> (64 - mod) | bits[i - div] << mod;
        if (div < n)
            bits[div] |= bits[0] << mod;
        _clean();
    }
    // Simulates `bs |= bs >> shift;`
    void or_shift_down(int64_t shift) {
        int64_t div = shift / 64, mod = shift % 64;
        if (mod == 0) {
            for (int64_t i = div; i < n; i++)
                bits[i - div] |= bits[i];
            return;
        }
        for (int64_t i = 0; i < n - (div + 1); i++)
            bits[i] |= bits[i + (div + 1)] << (64 - mod) | bits[i + div] >> mod;
        if (div < n)
            bits[n - div - 1] |= bits[n - 1] >> mod;
        _clean();
    }
    int64_t find_first() const {
        for (int i = 0; i < n; i++)
            if (bits[i] != 0)
                return 64 * i + __builtin_ctzll(bits[i]);
        return -1;
    }
    custom_bitset& operator&=(const custom_bitset &other) {
        assert(b == other.b);
        for (int i = 0; i < n; i++)
            bits[i] &= other.bits[i];
        return *this;
    }
};
// Computes all possible subset sums from 0 to n that can be made using values from sizes. Runs in O(n sqrt n / 64) if
// the sum of sizes is bounded by n, and O(n^2 / 64) otherwise.
custom_bitset possible_subsets_knapsack(int n, const vector<int> &sizes) {
    vector<int> freq(n + 1, 0);
    for (int s : sizes)
        if (1 <= s && s <= n)
            freq[s]++;
    custom_bitset knapsack(n + 1);
    knapsack.set(0, 1);
    for (int s = 1; s <= n; s++) {
        if (freq[s] >= 3) {
            int move = (freq[s] - 1) / 2;
            if (2 * s <= n) freq[2 * s] += move;
            freq[s] -= 2 * move;
        }
        for (int r = 0; r < freq[s]; r++)
            knapsack.or_shift(s);
    }
    return knapsack;
}
```

