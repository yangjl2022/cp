# 数学专题模板
- [数学专题模板](#数学专题模板)
- [数论](#数论)
  - [模P等价类](#模p等价类)
  - [欧拉筛](#欧拉筛)
  - [杜教筛](#杜教筛)
  - [因数分解](#因数分解)
  - [素性测试和大整数分解](#素性测试和大整数分解)
  - [其他](#其他)
    - [快速幂](#快速幂)
    - [扩展欧几里得](#扩展欧几里得)
    - [中国剩余定理](#中国剩余定理)
    - [原根](#原根)
    - [BSGS与exBSGS](#bsgs与exbsgs)
    - [离散对数](#离散对数)
    - [高次剩余](#高次剩余)
    - [二次剩余与三次剩余](#二次剩余与三次剩余)
    - [类欧几里得算法](#类欧几里得算法)
    - [Lucas与exLucas](#lucas与exlucas)
- [组合数学](#组合数学)
  - [逆元和阶乘逆元](#逆元和阶乘逆元)
  - [盒子放球计数](#盒子放球计数)
  - [斯特林数](#斯特林数)
- [线性代数](#线性代数)
  - [矩阵](#矩阵)
  - [高斯消元](#高斯消元)
  - [行列式](#行列式)
  - [线性基](#线性基)
- [Prufer序列](#prufer序列)
- [拉格朗日插值](#拉格朗日插值)
- [多项式](#多项式)
  - [快速傅里叶变换FFT](#快速傅里叶变换fft)
  - [快速数论变换NTT](#快速数论变换ntt)
  - [多项式在字符串匹配中的应用](#多项式在字符串匹配中的应用)
- [Min25筛](#min25筛)
- [快速沃尔什变换FWT](#快速沃尔什变换fwt)
  - [子集卷积FST](#子集卷积fst)
  - [分治FWT](#分治fwt)
- [常系数齐次线性递推](#常系数齐次线性递推)
- [群论](#群论)
  - [圆环涂色计数](#圆环涂色计数)
  - [置换和轮换](#置换和轮换)
  - [基环森林](#基环森林)
- [博弈论](#博弈论)
  - [mex运算](#mex运算)
  - [nim积](#nim积)


# 数论
## 模P等价类
```cpp
template<int P>
struct MInt {
    int x;
    constexpr MInt(): x(0) {}
    template<class T>
    constexpr MInt(T x): x(norm(x%P)) {}
    constexpr static int norm(int x) {
        return x<0? x+P: x>=P? x-P: x;
    }
    constexpr MInt inv() const{
        int a=x, b=P, u=1, v=0;
        while(b) {
            int t = a/b;
            swap((a-=t*b), b);
            swap((u-=t*v), v);
        }
        return u;
    }
    constexpr MInt operator-() const{
        return MInt()-*this;
    }
    constexpr MInt& operator+=(const MInt& a) {
        x=norm(x+a.x);
        return *this;
    }
    constexpr MInt& operator-=(const MInt& a) {
        x=norm(x-a.x);
        return *this;
    }
    constexpr MInt& operator*=(const MInt& a) {
        x=1ll*x*a.x%P;
        return *this;
    }
    constexpr MInt& operator/=(const MInt& a) {
        assert(a);
        return *this*=a.inv();
    }
    constexpr friend MInt operator+(MInt l,const MInt& r) {
        return l+=r;
    }
    constexpr friend MInt operator-(MInt l,const MInt& r) {
        return l-=r;
    }
    constexpr friend MInt operator*(MInt l,const MInt& r) {
        return l*=r;
    }
    constexpr friend MInt operator/(MInt l,const MInt& r) {
        return l/=r;
    }
    constexpr explicit operator bool()const {
        return x!=0;
    }
    constexpr bool operator!()const {
        return x==0;
    }
    friend ostream& operator<<(ostream& os,const MInt& a) {
        return os<<a.x;
    }
    string find_Fraction()const {
        for(int i=1; i<=1000000; ++i)
            if((*this*i).x<=100)
                return to_string((*this*i).x) + "/" + to_string(i);
        return "not find.";
    }
};
constexpr int P=998244353;
using Z=MInt<P>;
constexpr Z power(Z a, ll b) {
    Z ans(1);
    for(; b; b>>=1, a*=a)
        if(b&1) ans*=a;
    return ans;
}
template<int V>// invV<2> * 2 ==1 mod P
constexpr Z invV=power(V,P-2);
```

## 欧拉筛
```cpp
vector<bool> nPrime;
vector<int> prm,minp,phi,mo;// 质数集合、最小质因子、欧拉函数、莫比乌斯函数
vector<int> d, c;// 约数个数，最小质因子个数
void sieve(int n) {
    nPrime.resize(n+1), nPrime[1]=true;
    minp.resize(n+1);
    phi.resize(n+1), phi[1]=1;
    mo.resize(n+1), mo[1]=1;
    c.resize(n+1), c[1]=0;
    d.resize(n+1), d[1]=1;
    for(int i=2; i<=n; ++i) {
        if(!nPrime[i]) {
            prm.push_back(i);
            minp[i]=i;
            phi[i]=i-1;
            mo[i]=-1;
            c[i]=1;
            d[i]=2;
        }
        for(int j=0; prm[j]<=n/i; ++j) {
            int k=i*prm[j];
            nPrime[k]=true;
            minp[k]=prm[j];
            if (i%prm[j]==0) {
                phi[k]=phi[i]*prm[j];
                c[k]=c[i]+1;
                d[k]=d[i]/(1+c[i])*(1+c[k]);
                break;
            }
            phi[k]=phi[i]*(prm[j]-1);
            mo[k]=-mo[i];
            c[k]=1;
            d[k]=d[i]*2;
        }
    }
}
```

## 杜教筛
```cpp
unordered_map<int, ll> sphi;
ll Sphi(int n) {
    if(n<N) return phi[n];// 注意phi开int64 并且 求过前缀和
    if(sphi.count(n)) return sphi[n];
    ll ans=n*(n+1ll)/2;
    for(int l=2,r=1; l<=n&&r!=INT32_MAX; l=r+1) {
        r=n/(n/l);
        ans-=(r-l+1)*Sphi(n/l);
    }
    return sphi[n]=ans;
}
```

## 因数分解
```cpp
// 依次提取所有质因子（需要欧拉晒预处理每个数的最小质因子 minp）
auto demoByMinp(ll n) {
    vector<pair<ll,int>> ps;
	for(int p = minp[n]; n != 1; p = minp[n]) {
		int c = 0;
		for(; !(n % p); n /= p) c++;
		ps.emplace_back(p, c);
	}
    return ps;
}
// 根号枚举分解（最好枚举质因子）
auto demo(ll n) {
    vector<pair<ll,int>> pri;
    for(int i=2; i<=n/i; ++i)
        if(n%i==0) {// 枚举质因子 i 会更快
            pri.emplace_back(i, 0);
            while(n%i == 0) {
                n /= i;
                ++pri.back().second;
            }
        }
    if(n>1) pri.emplace_back(n,1);
    return pri;
}
template<class T, class Func>
void dfs_divisor(vector<pair<T,int>> const& ps, Func const& func,
        int id = 0, T s = 1, T phi = 1) {
    if(id >= ps.size()) {
        func(s, phi);
        // func(s);
        return;
    }
    auto const& [p,c] = ps[id];
    for(int i=0; i<=c; ++i) {
        dfs_divisor(ps, func, id+1, s, phi);
        s *= p;
        phi *= (i ? p : p-1);
    }
}
```

## 素性测试和大整数分解
```cpp
// from @Heltion
#include<random>
using i64 = long long;
using i128 = __int128_t;
i64 power(i64 a, i64 r, i64 mod) {
  i64 res = 1;
  for (; r; r >>= 1, a = (i128)a * a % mod) {
    if (r & 1) { res = (i128)res * a % mod; }
  }
  return res;
}
bool miller_rabin(i64 n) {
  static constexpr array<int, 9> p = {2, 3, 5, 7, 11, 13, 17, 19, 23};
  if (n == 1) { return false; }
  if (n == 2) { return true; }
  if (not(n % 2)) { return false; }
  int r = __builtin_ctzll(n-1);
  i64 d = (n - 1) >> r;
  for (int pi : p) {
    if (pi < n) {
      i64 x = power(pi, d, n);
      if (x == 1 or x == n - 1) { continue; };
      for (int j = 1; j < r; j += 1) {
        x = (i128)x * x % n;
        if (x == n - 1) { break; }
      }
      if (x != n - 1) { return false; }
    }
  }
  return true;
};
vector<i64> pollard_rho(i64 n) {
  static mt19937_64 mt;
  uniform_int_distribution uid(i64(0), n);
  if (n == 1) { return {}; }
  vector<i64> res;
  function<void(i64)> rho = [&](i64 n) {
    if (miller_rabin(n)) { return res.push_back(n); }
    i64 d = n;
    while (d == n) {
      d = 1;
      for (i64 k = 1, y = 0, x = 0, s = 1, c = uid(mt); d == 1;
           k <<= 1, y = x, s = 1) {
        for (int i = 1; i <= k; i += 1) {
          x = ((i128)x * x + c) % n;
          s = (i128)s * abs(x - y) % n;
          if (not(i % 127) or i == k) {
            d = gcd(s, n);
            if (d != 1) { break; }
          }
        }
      }
    }
    rho(d);
    rho(n / d);
  };
  rho(n);
  return res;
}
auto demo(ll n) {
    auto v = pollard_rho(n);
    sort(v.begin(), v.end());
    vector<pair<ll,int>> ps;
	for(int i=0,ii; i<v.size(); i=ii) {
		for(ii=i+1; ii<v.size() and v[i]==v[ii]; ii++);
		ps.emplace_back(v[i], ii-i);
	}
    return ps;
}
```

## 其他

### 快速幂
```cpp
int qmi(ll a,ll b,int p) {
    ll ans=1;
    for(; b; b>>=1,a=a*a%p)
        if(b&1) ans=ans*a%p;
    return ans;
}
```

### 扩展欧几里得
```cpp
template<class T>
T exgcd(T a,T b,T& x,T& y) {// |x|<=|a|,|y|<=|b|
    if(!b) return x=1, y=0, a;
    T d=exgcd(b,a%b,x,y), t=x;
    x=y, y=t-a/b*y;
    return d;
}
// 返回(x0,dx,m)，x=x0+k*dx（0<=k<m）。满足ax+by=c，其中x in [lx,hx]，y in [ly,hy]
tuple<ll,ll,ll> getRangeX(ll a,ll b,ll c,ll lx,ll hx,ll ly,ll hy) {
    c-=a*lx+b*ly;
    if(c<0) return {0,0,0};
    hx-=lx;// x in [0,hx]
    hy-=ly;// y in [0,hy]
    ll x,y,g=exgcd(a,b,x,y);
    if(c%g) return {0,0,0};
    ll dx=b/g;
    ll dy=a/g;
    x=c/g%dx*x%dx;
    if(x<0) x+=dx;// min x>=0
    y=(c-a*x)/b;
    ll l=max<ll>(0,(y-hy+dy-1)/dy);
    ll r=min<ll>((x>hx ? -1: (hx-x)/dx), (y<0? -1 : y/dy));
    if(l>r) return {0,0,0};
    return {x+l*dx,dx,r-l+1};
}
template<class T>
T inverse(T a,T p) {
    T x=1,y=0,mod=p;
    while(p!=0) {
        T t=a/p;
        a-=t*p, swap(a,p);
        x-=t*y, swap(x,y);
    }
    if(a!=1) return -1;// 不互质
    return (x%mod+mod)%mod;
}
```

### 中国剩余定理
```cpp
bool excrt(ll& a1, ll& m1, ll a2, ll m2) {
    // ans = k1*m1+a1 = k2*m2+a2
    ll x, y, gcd=exgcd(m1, m2, x, y), dx=m2/gcd;
    if ((a2-a1)%gcd) return false;
    x=((__int128_t)(a2-a1)/gcd*x%dx+dx)%dx;
    a1+=m1*x, m1*=m2/gcd;
    return true;
}
```

### 原根
```cpp
vector<int> findRoot(int n) {// n=1,2,4,p^a,2*p^a
    int phi=n, t=n;
    for(int i=2; i<=t/i; ++i) 
        if(t%i==0) {
            phi-=phi/i;
            while(t%i==0) t/=i;
        }
    if(t>1) phi-=phi/t;
    t=phi;
    vector<int> factor;
    for(int i=2; i<=t/i; ++i) 
        if(t%i==0) {
            factor.push_back(i);
            while(t%i==0) t/=i;
        }
    if(t>1) factor.push_back(t);
    vector<int> root;
    for(int g=1; g<=n; ++g) {
        if(__gcd(g,n)!=1) continue;
        int ok=1;
        for(int x:factor)
            if(qmi(g,phi/x,n)==1){
                ok=0;
                break;
            }
        if(ok) {
            root.push_back(g);
            break;
        }
    }
    if(root.size())
        for(int i=2; i<phi; ++i) 
            if(__gcd(i,phi)==1)
                root.push_back(qmi(root[0],i,n));
    return root;// not sorted
}
```

### BSGS与exBSGS
$O(\sqrt p)$
```cpp
int bsgs(int a,int b,int p) {// min{x|x>=0,a^x=b mod p},(a,p)=1
    if(b==1) return 0;
    int B=sqrt(p)+1, ri=1;
    unordered_map<int,int> id;
    for(int i=0; i<B; ++i,ri=(ll)ri*a%p)
        id[(ll)ri*b%p]=i;
    int le=ri;
    for(int i=1; i<=B; ++i,le=(ll)le*ri%p)
        if(id.count(le)) return i*B-id[le];
    return -1;
}
int exbsgs(int a,int b,int p) {// min{x|x>=0,a^x=b mod p}
    int k=0,sum=1;
    while(1) {
        if(sum==b||p==1) return k;
        int g=__gcd(a,p);
        if(g==1) break;
        if(b%g) return -1;
        b/=g, p/=g;
        ++k, sum=(ll)sum*a/g%p;
    }
    int res=bsgs(a,(ll)b*inverse(sum,p)%p,p);
    return res==-1?-1:res+k;
}
```

### 离散对数
预处理$O(2*10^6)$ ，单次询问 $O(\log A)$
```cpp
namespace IND {
    constexpr int P = 1e9 + 7;// prime
    constexpr int G = 5;// 原根
    constexpr int SQ = 31625;// sqrt(P)+3
    constexpr int LOG_1 = P>>1;// -1的指标
    constexpr int PHI = P-1;
    int ind[SQ+1];// 1~sqrt(P)的指标
    int norm(int x) {
        return x>=PHI ? x-PHI : x<0 ? x+PHI : x;
    }
    HashMap<int,int> id;// avoid hdoj's MLE using Handwritten Hash
    void init() {// O(2e6)
        constexpr int B = 1000;
        constexpr int lim = P/B+1;
        int gB=1;
        for(int i=1; i<=B; ++i)
            gB=1ll*gB*G%P;
        int t=gB;
        for(int i=1; i<=lim; ++i,t=1ll*t*gB%P)
            id[t]=i*B;// g^(aB-b)=x
        vector<int> prm;
        vector<bool> vis(SQ+1);
        for(int i=2; i<=SQ; ++i) {
            if(!vis[i]) {
                prm.push_back(i);
                for(int j=0,g=i; ;++j,g=1ll*g*G%P)
                    if(id.count(g)) {
                        ind[i]=norm(id[g]-j);
                        break;
                    }
            }
            for(int j=0; prm[j]<=SQ/i; ++j) {
                vis[i*prm[j]]=true;
                ind[i*prm[j]]=norm(ind[i]+ind[prm[j]]);
                if(i%prm[j]==0) break;
            }
        }
    }
    int qlog(int x) {// O(logx)
        if(x<=SQ) return ind[x];
        int q=P/x, r=P-q*x;
        return r<=x/2? norm(LOG_1+qlog(r)-ind[q]):norm(qlog(x-r)-ind[q+1]);
    }
}
```

设 $P-1=\sum{p_i^{k_i}}$ ，单次询问复杂度 $O(\sum{k_i * (\log P + \sqrt{p_i})})$
```cpp
template<class Int = int , class Long = long long>
struct PohligHellman {
    const Int m;// 模数
    const Int n;// n=m-1
    int g;
    vector<vector<Int>> prm;// 质因子
    vector<unordered_map<Int,int> > id;
    vector<int> Bl;
    vector<Int> coef;
    PohligHellman(Int P) : m(P), n(P-1) {
        auto nn=n;// 质因数分解
        for(int i=2; i<=nn/i; ++i) {
            if(nn%i==0) {
                nn/=i;
                prm.push_back({i});
                while(nn%i==0) {
                    nn/=i;
                    prm.back().push_back(prm.back().back()*i);
                }
            }
        }
        if(nn>1)
            prm.push_back({nn});
        for(g=2; ;++g) {// 寻找原根
            bool flag=true;
            for(int i=0; i<prm.size(); ++i)
                if(qmi(g,n/prm[i][0],m)==1) {
                    flag=false;
                    break;
                }
            if(flag) break;
        }
        id.resize(prm.size());// 预处理BS表
        for(int i=0; i<prm.size(); ++i) {
            const Int p=prm[i][0];
            const Int pk=prm[i].back();
            const int B=sqrt(p+.5);// 多次询问离散对数可以调小一点
            Bl.push_back(B);
            Int t=1, dt=qmi(g,n/p,m), T=1;
            for(int k=0; k<B; ++k, t=(Long)t*dt%m);
            for(int k=0; k<p/B; ++k, T=(Long)T*t%m)
                id[i][T]=k;
            coef.push_back((Long)n/pk*inv(n/pk,pk)%n);// crt系数
        }
    }
    Int qlog(Int b) {// g^x=b mod m
        Int x=0;
        for(int i=0; i<prm.size(); ++i) {
            const Int p=prm[i][0];
            Int sumx=0;
            for(int j=0; j<prm[i].size(); ++j) {
                // g^(x*n/p)=b^(n/prm[i][j]) * g^(-sumx*n/prm[i][j])
                Int t=(Long)qmi(b,n/prm[i][j],m) 
                    * qmi(g,n-(Long)sumx*n/prm[i][j]%n,m) % m;
                Int dt=qmi(g,n-n/p,m);
                for(int k=0; ;++k, t=(Long)t*dt%m)
                    if(id[i].count(t)) {
                        sumx+=(id[i][t]*Bl[i]+k)*(j?prm[i][j-1]:1);
                        break;
                    }
            }
            x=(x + (Long)sumx*coef[i])%n;
        }
        return x;
    }
    template<class T>
    T exgcd(T a,T b,T& x,T& y) {// |x|<=|a|,|y|<=|b|
        if(!b) return x=1, y=0, a;
        T d=exgcd(b,a%b,x,y), t=x;
        x=y, y=t-a/b*y;
        return d;
    }
private:
    Int qmi(Int a,Long b,Int p) {
        Long ans=1;
        for(; b; b>>=1,a=(Long)a*a%p)
            if(b&1) ans=ans*a%p;
        return ans;
    }
    Int inv(Int a,Int m) {
        Int x,y;
        exgcd(a,m,x,y);
        return (x+m)%m;
    }
};
```

如果内存足够开 $\sum(p^k)$ ，此算法可以优化。
设 $s$ 为 $P-1$ 的质因子种类数，单次询问 $O(s*\log P)$
```cpp
template<class Int = int , class Long = long long>
struct PohligHellman {
    const Int m;// 模数
    const Int n;// n=m-1
    int g;
    vector<Int> prm;
    vector<Int> pk;// p^k
    vector<unordered_map<Int,int> > id;
    vector<Int> coef;
    PohligHellman(Int P) : m(P), n(P-1) {
        auto nn=n;// 质因数分解
        for(int i=2; i<=nn/i; ++i) {
            if(nn%i==0) {
                prm.push_back(i);
                Int cur=1;
                while(nn%i==0)
                    nn/=i,cur*=i;
                pk.push_back(cur);
            }
        }
        if(nn>1)
            prm.push_back(nn),pk.push_back(nn);
        for(g=2; ; ++g) {// 寻找原根
            bool flag=true;
            for(auto p:prm)
                if(qmi(g, n/p, m)==1) {
                    flag=false;
                    break;
                }
            if(flag) break;
        }
        id.resize(pk.size());// 预处理 ( g^(n/pk) ) ^ t
        for(int i=0; i<pk.size(); ++i) {
            Int t=1, dt=qmi(g, n/pk[i], m);
            for(int j=0; j<pk[i]; ++j, t=(Long)t*dt%m)
                id[i][t]=j;
            coef.push_back((Long)n/pk[i] * inv(n/pk[i],pk[i])%n);// crt系数
        }
    }
    Int qlog(Int b) {// g^x=b mod m
        Int x=0;
        for(int i=0; i<pk.size(); ++i) {
            int r=id[i][qmi(b, n/pk[i], m)];
            x=(x + (Long)r*coef[i])%n;
        }
        return x;
    }
    template<class T>
    T exgcd(T a,T b,T& x,T& y) {// |x|<=|a|,|y|<=|b|
        if(!b) return x=1, y=0, a;
        T d=exgcd(b,a%b,x,y), t=x;
        x=y, y=t-a/b*y;
        return d;
    }
private:
    Int qmi(Int a,Long b,Int p) {
        Long ans=1;
        for(; b; b>>=1,a=(Long)a*a%p)
            if(b&1) ans=ans*a%p;
        return ans;
    }
    Int inv(Int a,Int m) {
        Int x,y;
        exgcd(a,m,x,y);
        return (x+m)%m;
    }
};
```

### 高次剩余
```cpp
vector<int> discreteRoots(int a,int b,int p) {
    // {x|x^a=b mod p},p is prime
    if(b==0) return {0};
    int g=findRoot(p), indb=bsgs(g,b,p);
    int indx,y,gcd=exgcd(a,p-1,indx,y);
    if(indb%gcd) return {};
    int dx=abs((p-1)/gcd);
    indx=((ll)indb/gcd*indx%dx+dx)%dx;
    int x=qmi(g,indx,p), Dx=qmi(g,dx,p);
    vector<int> ans;
    for(int i=indx; i<p-1; i+=dx,x=(ll)x*Dx%p)
        ans.push_back(x);
    return ans;// not sorted
}
```

### 二次剩余与三次剩余
```cpp
namespace Cipolla {
    ll p,w,a; // w=a*a-n
    struct CP{
        ll x,y;
        CP(ll x, ll y):x(x),y(y) {}
    };
    CP mul(const CP& a, const CP& b) {
        return CP((a.x*b.x+a.y*b.y%p*w)%p,(a.x*b.y+a.y*b.x)%p);
    }
    CP qmiCP(CP a, ll b) {
        CP ans(1,0);
        for(; b; b>>=1,a=mul(a,a)) if(b&1) ans=mul(ans,a);
        return ans;
    }
    void solve(ll n, ll _p, ll&ans1, ll&ans2) {
        p=_p, ans1=ans2=-1;
        if(n==0||p==2) { ans1=n; return; }
        if(qmi(n,(p-1)>>1,p)==p-1) return;
        while(true) {
            a=rand(),w=(a*a-n+p)%p;
            if(qmi(w,(p-1)>>1,p)==p-1) {
                ans1=qmiCP(CP(a,1), (p+1)>>1).x;
                ans2=p-ans1;
                break;
            }
        }
    }
}
namespace CubeRoot {
    ll n,p,w; // (2*w+1)*(2*w+1)=-3
    struct TRI {
        ll x,y,z;
        TRI(ll x,ll y,ll z):x(x),y(y),z(z) {}
    };
    TRI mul(const TRI& a, const TRI& b) {
        return TRI((a.x*b.x+a.y*b.z%p*n+a.z*b.y%p*n)%p,
            (a.x*b.y+a.y*b.x+a.z*b.z%p*n)%p,
            (a.x*b.z+a.y*b.y+a.z*b.x)%p );
    }
    TRI qmiTRI(TRI a,ll b) {
        TRI ans(1,0,0);
        for(; b; b>>=1,a=mul(a,a)) if(b&1) ans=mul(ans,a);
        return ans;
    }
    void solve(ll _n, ll _p, ll&ans1, ll&ans2, ll&ans3) {
        n=_n, p=_p, ans1=ans2=ans3=-1;
        if(n==0||p==2||p==3) { ans1=n; return; }
        if(p%3==2) { ans1=qmi(n,(2*p-1)/3, p); return; }
        if(qmi(n,(p-1)/3,p)!=1) return;
        ll tmp;
        Cipolla::solve(p-3,p,w,tmp);
        w=(w-1)*((p+1)>>1)%p;
        while(true) {
            TRI v(rand()%p,rand()%p+1,rand()%p+1);
            v=qmiTRI(v,(p-1)/3);
            if(v.x==0&&v.z==0) {
                ans1=qmi(v.y,p-2,p);
                ans2=ans1*w%p;
                ans3=ans2*w%p;
                break;
            }
        }
    }
}
```

### 类欧几里得算法  
$O(\log n)$
```cpp
constexpr Z inv2=Z(2).inv();
constexpr Z inv6=Z(6).inv();
template<class T>
struct Data {
    T f;// f=sum_{i=0~n}{ (ai+b)/c }
    T g;// g=sum_{i=0~n}{ i*((ai+b)/c) }
    T h;// h=sum_{i=0~n}{ ((ai+b)/c)^2 }
};
template<class T,class i32=int,class i64=long long>
Data<T> cal(i32 a,i32 b,i32 c,i32 n) { // a,b,n>=0,c>0
    T s0=n+1, bc=b/c, ac=a/c;
    T s1=T(n)*(n+1)*inv2;
    T s2=T(n)*(n+1)*(T(2)*n+1)*inv6;
    if(a==0) return { bc*s0, bc*s1, bc*bc*s0 };
    if(a>=c || b>=c) {
        Data<T>&& d=cal<T>(a%c,b%c,c,n);
        return {
            d.f+ac*s1+bc*s0,
            d.g+ac*s2+bc*s1,
            d.h+2*bc*d.f+2*ac*d.g+ac*ac*s2+bc*bc*s0+ac*bc*n*(n+1)
        };
    }
    i32 m=((i64)a*n+b)/c;
    Data<T>&& d=cal<T>(c,c-b-1,a,m-1);
    return {
        T(n)*m-d.f,
        (T(m)*n*(n+1)-d.h-d.f)*inv2,
        T(n)*m*m-2*d.g-d.f
    };
}
```

### Lucas与exLucas
```cpp
int fac[N],infac[N];
void initFac(int n,int p) {
    n=min(n,p-1);
    fac[0]=infac[0]=1;
    for(int i=1; i<=n; ++i) fac[i]=(ll)fac[i-1]*i%p;
    infac[n]=qmi(fac[n],p-2,p);
    for(int i=n-1; i>=1; --i) infac[i]=(ll)infac[i+1]*(i+1)%p;
}
int binom(int n,int m,int p) {// n,m<p
    if(m<0 || n<m) return 0;
    return (ll)fac[n]*infac[m]%p*infac[n-m]%p;
}
int lucas(ll n,ll m,int p) {// C(n,m)%p
    if(m<0 || n<m) return 0;
    if(!m) return 1;
    return (ll)lucas(n/p,m/p,p)*binom(n%p,m%p,p)%p;
}
```

```cpp
int calc(ll n,int p,int p_a) {// n!/p^x mod p_a
    if(!n) return 1;
    ll sum=1;
    for(int i=1; i<=p_a; ++i) 
        if(i%p) sum=sum*i%p_a;
    sum=qmi(sum,n/p_a,p_a);
    for(int i=n%p_a; i>=1; --i)
        if(i%p) sum=sum*i%p_a;
    return sum*calc(n/p,p,p_a)%p_a;
}
int exlucas2(ll n,ll m,int p,int p_a) {// C(n,m)%p^a
    if(m<0 || n<m) return 0;
    ll cnt=0;
    for(ll x=n/p; x; x/=p) cnt+=x;
    for(ll x=m/p; x; x/=p) cnt-=x;
    for(ll x=(n-m)/p; x; x/=p) cnt-=x;
    return (ll)qmi(p,cnt,p_a)*calc(n,p,p_a)%p_a
            *inverse(calc(m,p,p_a),p_a)%p_a
            *inverse(calc(n-m,p,p_a),p_a)%p_a;
}
int exlucas(ll n,ll m,int M) {// C(n,m)%M
    if(m<0 || n<m) return 0;
    ll r=0,mod=1;
    for(int i=2; i<=M/i; ++i)
        if(M%i==0) {
            int p=i, p_a=1;
            while(M%i==0) M/=i,p_a*=i;
            excrt(r,mod,exlucas2(n,m,p,p_a),p_a);
        }
    if(M>1) excrt(r,mod,exlucas2(n,m,M,M),M);
    return r;
}
```

# 组合数学
## 逆元和阶乘逆元
```cpp
vector<Z> inv, fac, infac;
void initFac(int n) {
    n = min(n, P-1);
    inv.resize(n+1, 1);
    fac.resize(n+1, 1);
    infac.resize(n+1, 1);
    for(int i=2; i<=n; ++i) {
        fac[i] = fac[i-1] * i;
        inv[i] = -P/i * inv[P%i];
        infac[i] = infac[i-1] * inv[i];
    }
}
Z binom(int n, int m) {// n,m<P
    if(m < 0 or n < m) return 0;
    assert(n < fac.size());
    return fac[n] * infac[m] * infac[n-m];
}
```

## 盒子放球计数
```cpp
// ball个球放n个盒子里,盒子可以为空
Z placeNum(int ball,int n) {
    if(!n) return ball==0;
    return binom(n-1+ball,ball);
}
// ball个球放n个盒子里,刚好ball0个球放在前n0个盒子里,盒子可以为空
Z numOf(int ball,int n,int ball0,int n0) {
    return placeNum(ball0,n0)*placeNum(ball-ball0,n-n0);
}
// n个球分配到m个盒子里，每个盒子最多放r个球的方案数，容斥O(m)解决
Z distribute(int n,int m,int r) {
    if(!m) return n==0;
    Z ans = 0;
    for(int i=0, up=min(m, n/(r+1)); i<=up; ++i) {
        ans += (i&1?-1:1) * binom(m, i) * binom(n-i*(r+1)+m-1, m-1);
    }
    return ans;
}
```

## 斯特林数
```cpp
Poly MovePoly(const Poly& f,int c) {//多项式平移f(x+c)
    int n=f.size()-1;
    Poly A(n+1),B(n+1);
    for(int i=0; i<=n; ++i) A[i]=mul(f[n-i],fac[n-i]);
    for(int i=0,ci=1; i<=n; ++i,ci=mul(ci,c)) B[i]=mul(ci,infac[i]);
    Poly C=A*B,g(n+1);
    for(int t=0; t<=n; ++t) g[t]=mul(C[n-t],infac[t]);
    return g;
}
Poly S1row(int n) {//x的n次上升幂
    if(n==1) return Poly{0,1};
    Poly f=S1row(n>>1), fc=MovePoly(f,n>>1);
    f=f*fc; f.resize(n+1);
    if(n&1) //x+n-1
        for(int i=n; i>=0; --i)
            f[i]=add(mul(f[i],n-1),i?f[i-1]:0);
    return f;
}
Poly S1column(int n,int k) { //c(n,k)=f(n)*fac[n]
    Poly f(n); //x + x^2/2 + x^3/3 + ... +x^n/n
    for(int i=1; i<=n; ++i) f[i-1]=inv[i];
    f=qmi(f,k,n+1)*infac[k];
    f.insert(f.begin(),k,0), f.resize(n+1);
    return f;
}
Poly S2row(int n) {
    Poly f(n+1),g(n+1);
    for(int i=0; i<=n; ++i) {
        f[i]=mul((i&1?mod-1:1),infac[i]);
        g[i]=mul(qmi(i,n),infac[i]);
    }
    Poly h=f*g; h.resize(n+1);
    return h;
}
Poly S2column(int n,int k) { //S2(n,k)=f(n)*fac[n]
    Poly f(n);
    for(int i=1; i<=n; ++i) f[i-1]=infac[i];
    f=qmi(f,k,n+1)*infac[k];
    f.insert(f.begin(),k,0); f.resize(n+1);
    return f;
}
```

# 线性代数
## 矩阵
```cpp
namespace mat {
    const int P=1e9+7;
    template<size_t R,size_t C>
    struct Mat{
        int at[R][C];
        auto& operator[](int idx) {
            return at[idx];
        }
        const auto& operator[](int idx)const {
            return at[idx];
        }
    };
    template<size_t N,size_t M>
    ostream& operator<<(ostream& out,Mat<N,M> it) {
        out<<"{";
        for (int i=0; i<N; ++i)
            for (int j=0; j<M; ++j)
                out<<it[i][j]<<",";
        return out<<"}";
    }
    template<size_t R> 
    void turn_E(Mat<R,R>& a) {
        for (int i=0; i<R; ++i)
            for (int j=0; j<R; ++j)
                a[i][j]=(i==j);
    }
    template<size_t R,size_t C,size_t H> 
    Mat<R,H> operator*(const Mat<R,C>& a,const Mat<C,H>& b) {
        static Mat<R,H> res;
        for (int i=0; i<R; ++i)
            for (int j=0,k; j<H; ++j)
                for (k=res[i][j]=0; k<C; ++k)
                    res[i][j]=(res[i][j]+1ll*a[i][k]*b[k][j])%P;
        return res;
    }
    template<size_t R> 
    Mat<R,R> operator^(Mat<R,R> a,ll n) {
        static Mat<R,R> res;
        turn_E(res);
        for(; n; n>>=1,a=a*a)
            if(n&1) res=res*a;
        return res;
    }
    template<size_t R> 
    Mat<R,R> operator^(const Mat<R,R>& a,const string& s) {
        static Mat<R,R> res;
        turn_E(res);
        for(int i=0; i<s.size(); ++i)
            res=res^10, res=res*(a^(s[i]-'0'));
        return res;
    }
    int qmi(int a,ll b){
        int ans=1;
        for(; b; b>>=1,a=1ll*a*a%P)
            if(b&1)	ans=1ll*ans*a%P;
        return ans;
    }
    template<size_t R> 
    Mat<R,R> inverse(Mat<R,R> a,int n=R) {
        //[0,n)[0,n)矩阵求逆，无逆元时res[0][0]=-1
        static Mat<R,R> res;
        turn_E(res);
        for (int i=0,r; i<n; ++i) {
            r=i;
            for (int j=i+1; j<n; ++j)
                if (a[j][i]>a[r][i]) r=j;
            swap(a[i],a[r]), swap(res[i],res[r]);
            if (!a[i][i]) return res[0][0]=-1,res;//矩阵的秩<n,无逆元

            ll invaii=qmi(a[i][i],P-2);
            for (int k=0; k<n; ++k) a[i][k]=a[i][k]*invaii%P;
            for (int k=0; k<n; ++k) res[i][k]=res[i][k]*invaii%P;
            for (int j=0; j<n; ++j)
                if (j!=i) {
                    ll tmp=a[j][i];
                    for (int k=i; k<n; ++k) 
                        a[j][k]=(a[j][k]-tmp*a[i][k]%P+P)%P;
                    for (int k=0; k<n; ++k) 
                        res[j][k]=(res[j][k]-tmp*res[i][k]%P+P)%P;
                }
        }
        return res;
    }
}
```

## 高斯消元
$O(n*m*\min(n,m))$
```cpp
template<class T>
struct Gauss {// index-0
    int n,m;
    vector<vector<T>> A;// 系数矩阵
    vector<T> b;// 常数矩阵
    vector<int> free;
    // 未知数矩阵 Yi是自由变元，随意取值
    // x0=c0+ Y0 * d00 + Y1 * d10 +..
    // x1=c1+ Y0 * d01 + Y1 * d11 +..
    vector<vector<T>> x;// 未知数矩阵
    Gauss(int n,int m): n(n),m(m),A(n,vector<T>(m)),b(n),x(m) {}
    void print() {
        cerr<<endl<<n<<"*"<<m<<" Matrix:"<<endl;
        for(int i=0; i<A.size(); ++i) {
            for(auto& e:A[i])
                cerr<<e<<" ";
            cerr<<b[i]<<endl;
        }
    }
    bool solve() {
        int c=0, r=0;
        for(; r<n && c<m; ++r, ++c) {
            int r1=-1;
            for(int i=r; i<n; ++i)
                if(A[i][c]) {
                    r1=i;
                    break;
                }
            if(r1==-1) {
                free.push_back(c);
                --r;
                continue;
            }
            if(r1!=r) {
                swap(A[r],A[r1]);
                swap(b[r],b[r1]);
            }
            T t=T(1)/A[r][c];
            for(int j=c; j<m; ++j)
                A[r][j]*=t;
            b[r]*=t;
            for(int i=0; i<n; ++i) {
                if(i==r || !A[i][c]) continue;
                T t=A[i][c];
                for(int j=c; j<m; ++j)
                    A[i][j]-=t*A[r][j];
                b[i]-=t*b[r];
            }
        }
        for(int i=r; i<n; ++i)
            if(b[i])
                return false;
        while(c<m)
            free.push_back(c++);
        for(int i=0,j=0,id=0; j<m; ++i,++j) {
            while(j<m && (i>=n||!A[i][j]) ) {
                x[j].assign(free.size()+1,0);
                x[j][id+1]=1;
                ++j, ++id;
            }
            if(j>=m) break;
            x[j].assign(free.size()+1,0);
            x[j][0]=b[i];// 特解
            for(int k=0; k<free.size(); ++k)
                x[j][k+1]=-A[i][free[k]];
        }
        return true;
    }
};
```

$Z_2$ 域下的方程组可以用 $bitset$ 优化
$O(n*m*\min(n,m)/64)$
```cpp
struct Gauss {// index-0
    bitset<N> A[N];// 第m列A[i][m]是常数列
    int x[N];
    void print(int n,int m) {
        cerr<<endl<<n<<"*"<<m<<" Matrix:"<<endl;
        for(int i=0; i<n; ++i) {
            for(int j=0; j<m; ++j)
                cerr<<A[i][j];
            cerr<<A[i][m]<<endl;
        }
    }
    bool solve(int n,int m) {
        int c=0, r=0;
        for(; r<n && c<m; ++r, ++c) {
            int r1=-1;
            for(int i=r; i<n; ++i)
                if(A[i][c]) {
                    r1=i;
                    break;
                }
            if(r1==-1) {
                --r;
                continue;
            }
            if(r1!=r)
                swap(A[r],A[r1]);
            for(int i=0; i<n; ++i) {
                if(i==r || !A[i][c]) continue;
                A[i]^=A[r];
            }
        }
        for(int i=r; i<n; ++i)
            if(A[i][m])
                return false;
        for(int i=0,j=0; j<m; ++i,++j) {
            while(j<m && (i>=n||!A[i][j]) )
                x[j++]=0;// free
            if(j<m)
                x[j]=A[i][m];
        }
        return true;
    }
} g;
```

## 行列式
```cpp
// 求行列式对质数取模或者浮点型计算
Z det() {
    Z ans=1;
    int f=1;
    for (int i=1; i<=n; ++i) {
        int j=i;
        for(; j<=n; ++j)
            if(a[j][i].x)
                break;
        if(j>n)
            return 0;
        if(j!=i) {
            f=-f;
            swap(a[i], a[j]);
        }
        ans*=a[i][i];
        // 消除下面的系数
        Z inv=a[i][i].inv();
        for(int j=i+1; j<=n; ++j)
            if(a[j][i].x) {
                Z t=a[j][i]*inv;
                for (int k=i; k<=n; ++k)
                    a[j][k]-=a[i][k]*t;
            }
    }
    return ans*f;
}
```

```cpp
// 求行列式对非质数取模 或者 不取模
// 注意调用后a[][]会被修改
int det(int a[][N], int n) {
    int ans=1;
    for (int i=1; i<=n; ++i)
        for (int j=i+1; j<=n; ++j) {
            while (a[i][i]) {
                int div=a[j][i]/a[i][i];
                for (int k=i; k<=n; ++k) {
                    a[j][k]=(a[j][k]+p-1ll*a[i][k]*div%p)%p;
                }
                swap(a[i], a[j]);
                ans=-ans;
            }
            swap(a[i], a[j]);
            ans=-ans;
        }
    for (int i=1; i<=n; ++i) ans=1ll*ans*a[i][i]%p;
    return (ans+p)%p;
}
```

## 线性基
```cpp
template<class T>
struct LinearBase {
    int LOG, has0;
    vector<T> base;
    LinearBase(): LOG(sizeof(T)<<3),has0(),base(LOG) {}
    bool push(T x) {
        for(int i=LOG-1; ~i; --i)
            if(x>>i&1) {
                if(!base[i]) {
                    base[i]=x;
                    return true;
                }
                x^=base[i];
            }
        has0=1;// get 0
        return false;
    }
    bool query(T x) {
        for(int i=LOG-1; ~i; --i)
            if(x>>i&1) {
                if(!base[i]) return false;
                x^=base[i];
            }
        return true;
    }
    T query_max(T ans = 0) {
        for(int i=LOG-1; ~i; --i)
            if((ans^base[i])>ans)
                ans^=base[i];
        return ans;
    }
    T query_min() {
        if(has0) return 0;
        for(int i=0; i<LOG; ++i)
            if(base[i]) return base[i];
        return 0;
    }
};
```

查询第k小
```cpp
vector<T> fixed;
void rebuild() {
    fixed=base;
    for(int i=LOG-1; i>=0; --i)
        for(int j=i-1; j>=0; --j)
            if(fixed[i]>>j&1)
                fixed[i]^=fixed[j];
    fixed.erase(remove(fixed.begin(),fixed.end(),T()),fixed.end());
}
T query_kth(T k) {
    k-=has0;
    if(!k) return 0;
    if(k>=1ll<<fixed.size()) return -1;
    T ans(0);
    for(int i=0; i<fixed.size(); ++i)
        if(k>>i&1) ans^=fixed[i];
    return ans;
}
```

# Prufer序列
```cpp
int n, deg[N]; //以n为根,节点i的孩子个数
int f[N];//以n为根,节点i的父节点
int prufer[N];
void tree_to_prufer() {
    for (int i=1; i<n; ++i) cin>>f[i], deg[f[i]]++;
    for (int i=1, j=1; i<=n-2; ++j) {
        while (deg[j]) j++;
        prufer[i++]=f[j];
        while (i<=n-2 && --deg[prufer[i-1]]==0 && prufer[i-1]<j)
            prufer[i]=f[prufer[i-1]], i++;
    }
}
void prufer_to_tree() {
    for (int i=1; i<=n-2; ++i) cin>>prufer[i], deg[prufer[i]]++;
    prufer[n-1]=n;
    for (int i=1, j=1; i<n; ++i, ++j) {
        while (deg[j]) j++;
        f[j]=prufer[i];
        while (i<n && --deg[prufer[i]]==0 && prufer[i]<j)
            f[prufer[i]]=prufer[i+1], i++;
    }
}
```

# 拉格朗日插值
```cpp
namespace LagrangeInterpolation {
    using T=Z;
    using Poly=vector<T>;
    // n次多项式，已知[x0,x0+n]的函数值y0~yn，求f(k)，O(n)
    template<class Arr>
    T getByContinuousX(int x0,const Arr& y,int n,int k) {
        k-=x0;
        if(k>=0&&k<=n) return y[k];
        vector<T> pre(n+1,k), suf(n+1,k-n);
        for(int i=1; i<=n; ++i) pre[i]=pre[i-1]*(k-i);
        for(int i=n-1; i>=0; --i) suf[i]=suf[i+1]*(k-i);
        T ans=0;
        for(int i=0; i<=n; ++i) {
            T tmp=y[i]*infac[i]*infac[n-i];
            if(i) tmp*=pre[i-1];
            if(i<n) tmp*=suf[i+1];
            if((n-i)&1) tmp=-tmp;
            ans+=tmp;
        }
        return ans;
    }
    // n次多项式，已知x0~xn的函数值y0~yn，求f(k)，O(n^2)
    template<class Arr>
    T getByAny(const Arr& x,const Arr& y,int n,T k) {
        T ans=0;
        for(int i=0; i<=n; ++i) {
            T sum=y[i],s=1;
            for(int j=0; j<=n; ++j) {
                if(j==i) continue;
                sum*=k-x[j];
                s*=x[i]-x[j];
            }
            ans+=sum/s;
        }
        return ans;
    }
    Poly Mul(Poly f,T a) {// f(x)*(x+a)
        f.insert(f.begin(),0);
        for(int i=0; i+1<f.size(); ++i)
            f[i]+=f[i+1]*a;
        return f;
    }
    Poly Div(Poly f,T a) {// f(x)/(x+a)
        for(int i=(int)f.size()-2; i>=0; --i)
            f[i]-=f[i+1]*a;
        f.erase(f.begin());
        return f;
    }
    // 已知x0~xn的函数值y0~yn，求f(x)的各项系数，O(n^2)
    template<class Arr>
    Poly lagrange(const Arr& x,const Arr& y,int n) {
        Poly f(n+1),S(1,1);
        for(int i=0; i<=n; ++i) 
            S=Mul(S,-x[i]);
        for(int i=0; i<=n; ++i) {
            T s=1;
            for(int j=0; j<=n; ++j)
                if(j!=i) s*=x[i]-x[j];
            s=y[i]/s;
            Poly g=Div(S,-x[i]);
            for(int i=0; i<=n; ++i)
                f[i]+=s*g[i];
        }
        return f;
    }
    // 根据函数表达式求一个点值，O(n)
    T getByPoly(const Poly& f,T x) {
        T ans=0, px=1;
        for(int i=0; i<f.size(); ++i,px*=x)
            ans+=f[i]*px;
        return ans;
    }
} using namespace LagrangeInterpolation;
```

# 多项式
## 快速傅里叶变换FFT
```cpp
namespace FFT {
    using T=double;
    const T PI=acos(-1);
    struct Comp {
        T a,b;
        Comp(T a=0,T b=0): a(a),b(b) {}
        Comp operator+(const Comp& it) const{ return Comp(a+it.a, b+it.b); }
        Comp operator-(const Comp& it) const{ return Comp(a-it.a, b-it.b); }
        Comp operator*(const Comp& it) const{ return Comp(a*it.a-b*it.b,a*it.b+b*it.a); }
        Comp conj() const{ return Comp(a,-b); }
    };
    void dft(vector<Comp>& a) {
        static vector<int> rev;
        int n=a.size();
        if(rev.size()!=n) {
            rev.resize(n);
            for(int i=1; i<n; ++i)
                rev[i]=rev[i>>1]>>1|(i&1?n>>1:0);
        }
        for(int i=0; i<n; ++i)
            if(i<rev[i]) swap(a[i], a[rev[i]]);
        // w[i]=w(highbit(i)*2, i-highbit(i))
        static vector<Comp> w{Comp(),Comp(1,0)};
        if(w.size()<n) {
            int k=__builtin_ctz(w.size());
            w.resize(n);
            for(; (1<<k)<n; ++k) {
                // w(1<<(k+1),1)
                Comp e(cos(PI/(1<<k)),sin(PI/(1<<k)));
                for(int i=(1<<(k-1)); i<(1<<k); ++i) {
                    w[i<<1]=w[i];
                    w[i<<1|1]=w[i]*e;
                }
            }
        }
        for(int m=1; m<n; m<<=1)
            for(int i=0; i<n; i+=m<<1)
                for(int j=0; j<m; ++j) {
                    Comp B=a[i+j], C=a[i+m+j]*w[m+j];
                    a[i+j]=B+C, a[i+m+j]=B-C;
                }
    }
    void idft(vector<Comp>& a) {
        dft(a);
        reverse(a.begin()+1,a.end());
        for(auto& x:a) 
            x.a/=a.size(),x.b/=a.size();
    }
    #define fftTag 1 // 2:三次变两次优化 3:任意模数多项式乘法
    #if fftTag==1
    using Poly=vector<int>;
    Poly operator*(const Poly& a,const Poly& b) {
        if(a.empty()||b.empty()) return Poly();
        int len=1, sz=a.size()+b.size()-1;
        while(len<sz)
            len<<=1;
        vector<Comp> A(len),B(len);
        for(int i=0; i<len; ++i) {
            if(i<a.size()) A[i].a=a[i];
            if(i<b.size()) B[i].a=b[i];
        }
        dft(A), dft(B);
        for(int i=0; i<len; ++i) 
            A[i]=A[i]*B[i];
        idft(A);
        Poly c(sz);
        for(int i=0; i<sz; ++i) 
            c[i]=A[i].a+0.5;
        return c;
    }
    #elif fftTag==2
    using Poly=vector<int>;
    Poly operator*(const Poly& a,const Poly& b) {
        if(a.empty()||b.empty()) return Poly();
        int len=1, sz=a.size()+b.size()-1;
        while(len<sz)
            len<<=1;
        vector<Comp> f(len), g(len);
        for(int i=0; i<len; ++i) {
            if(i<a.size()) f[i].a=a[i];
            if(i<b.size()) f[i].b=b[i];
        }
        dft(f);
        for(int i=0; i<len; ++i) {
            Comp cf=f[i?len-i:0].conj();
            g[i]=(f[i]+cf)*(f[i]-cf)*Comp(0,-0.25);
        }
        idft(g);
        Poly c(sz);
        for(int i=0; i<sz; ++i) 
            c[i]=g[i].a+0.5;
        return c;
    }
    #else
    using Poly=vector<Z>;
    Poly operator*(const Poly& a,const Poly& b) {
        if(a.empty()||b.empty()) return Poly();
        int len=1, sz=a.size()+b.size()-1;
        while(len<sz)
            len<<=1;
        vector<Comp> f(len), g(len), h(len);
        for(int i=0; i<a.size(); ++i)
            f[i]=Comp(a[i].x>>15,a[i].x&0x7fff);
        for(int i=0; i<b.size(); ++i)
            h[i]=Comp(b[i].x>>15,b[i].x&0x7fff);
        dft(f), dft(h);
        for(int i=0; i<len; ++i)
            g[i]=f[i?len-i:0].conj()*h[i];
        for(int i=0; i<len; ++i)
            f[i]=f[i]*h[i];
        idft(f), idft(g);
        Poly c(sz);
        for(int i=0; i<sz; ++i) {
            int AC=(ll)((f[i].a+g[i].a)/2+0.5)%P;
            int AD=(ll)((f[i].b+g[i].b)/2+0.5)%P;
            int BD=(ll)(g[i].a-AC+0.5)%P;
            int BC=(ll)(f[i].b-AD+0.5)%P;
            c[i]=(((ll)AC<<30)+((ll)(AD+BC)<<15)+BD)%P;
        }
        return c;
    }
    #endif
} using namespace FFT;
```

## 快速数论变换NTT
只含多项式乘法的简短版本，适合赛场用
```cpp
constexpr int P = 998244353;
int norm(int x) { return x<0? x+P: x>=P? x-P: x; }
struct Z {
    int x;
    Z(): x() {}
    Z(int x): x(norm(x)) {}// manually check x in range [-P,2P)
    friend Z operator+(const Z& l,const Z& r) { return norm(l.x+r.x); }
    friend Z operator-(const Z& l,const Z& r) { return norm(l.x-r.x); }
    friend Z operator*(const Z& l,const Z& r) { return 1ll*l.x*r.x%P; }
};
Z power(Z a, ll b) {
    Z ans = 1;
    for(; b; b>>=1, a=a*a)
        if(b&1) ans=ans*a;
    return ans;
}
using Poly = vector<Z>;
void dft(Poly& a) {
    static vector<int> rev;
    int n = a.size();
    if(rev.size() != n) {
        rev.resize(n);
        for(int i=1; i<n; ++i)
            rev[i] = rev[i>>1]>>1 | (i&1 ? n>>1 : 0);
    }
    for(int i=0; i<n; ++i)
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    static vector<Z> w{0,1};
    if(w.size() < n) {
        int k = __builtin_ctz(w.size());
        w.resize(n);
        for(; (1<<k) < n; ++k) {
            Z e = power(3, (P-1)>>(k+1));
            for(int i = (1<<k-1); i < (1<<k); ++i) {
                w[i<<1] = w[i];
                w[i<<1|1] = w[i]*e;
            }
        }
    }
    for(int m=1; m<n; m<<=1)
        for(int i=0; i<n; i+=m<<1)
            for(int j=0; j<m; ++j) {
                Z B = a[i+j], C = a[i+m+j]*w[m+j];
                a[i+j] = B+C, a[i+m+j] = B-C;
            }
}
void idft(Poly& a) {
    dft(a);
    reverse(a.begin()+1, a.end());
    Z inv = (1-P) / (int)a.size();
    for(auto& x:a)
        x = x*inv;
}
Poly operator*(Poly a, Poly b) {
    if(a.empty() || b.empty()) return Poly();
    int len = 1, sz = a.size()+b.size()-1;
    while(len < sz)
        len <<= 1;
    a.resize(len), dft(a);
    b.resize(len), dft(b);
    for(int i=0; i<len; ++i)
        a[i] = a[i] * b[i];
    idft(a);
    a.resize(sz);
    return a;
}
```

完整版
```cpp
namespace NTT {
    using Poly=vector<Z>;
    Poly mulxk(Poly a,int k) {
        a.insert(a.begin(),k,0);
        return a;
    }
    Poly divxk(const Poly& a,int k) {
        if(a.size()<=k) return Poly();
        return Poly(a.begin()+k,a.end());
    }
    Poly modxk(const Poly& a,int k) {
        k=min(k,(int)a.size());
        return Poly(a.begin(),a.begin()+k);
    }
    Poly operator+(const Poly& a,const Poly& b) {
        Poly c(a);
        c.resize(max(a.size(),b.size()));
        for(int i=0; i<b.size(); ++i) c[i]+=b[i];
        return c;
    }
    Poly operator-(const Poly& a,const Poly& b) {
        Poly c(a);
        c.resize(max(a.size(),b.size()));
        for(int i=0; i<b.size(); ++i) c[i]-=b[i];
        return c;
    }
    Poly operator-(Poly a) {
        for(auto& x:a) x=-x;
        return a;
    }
    #if fftTag==3
    using FFT::operator*;
    #else
    void dft(Poly& a) {
        static vector<int> rev;
        int n=a.size();
        if(rev.size()!=n) {
            rev.resize(n);
            for(int i=1; i<n; ++i)
                rev[i]=rev[i>>1]>>1|(i&1?n>>1:0);
        }
        for(int i=0; i<n; ++i)
            if(i<rev[i]) swap(a[i], a[rev[i]]);
        // w[i]=w(highbit(i)*2, i-highbit(i))
        static vector<Z> w{0,1};
        if(w.size()<n) {
            int k=__builtin_ctz(w.size());
            w.resize(n);
            for(; (1<<k)<n; ++k) {
                // w(1<<(k+1),1)
                Z e=power(3, (P-1)>>(k+1));
                for(int i=(1<<(k-1)); i<(1<<k); ++i) {
                    w[i<<1]=w[i];
                    w[i<<1|1]=w[i]*e;
                }
            }
        }
        for(int m=1; m<n; m<<=1)
            for(int i=0; i<n; i+=m<<1)
                for(int j=0; j<m; ++j) {
                    Z B=a[i+j], C=a[i+m+j]*w[m+j];
                    a[i+j]=B+C, a[i+m+j]=B-C;
                }
    }
    void idft(Poly& a) {
        dft(a);
        reverse(a.begin()+1,a.end());
        Z inv=(1-P)/(int)a.size();
        for(auto& x:a) x*=inv;
    }
    Poly operator*(Poly a,Poly b) {
        if(a.empty()||b.empty()) return Poly();
        int len=1, sz=a.size()+b.size()-1;
        while(len<sz) len<<=1;
        a.resize(len), dft(a);
        b.resize(len), dft(b);
        for(int i=0; i<len; ++i) a[i]*=b[i];
        idft(a);
        a.resize(sz);
        return a;
    }
    #endif
    Poly operator*(Poly a,Z b) {
        for(auto& x:a) x*=b;
        return a;
    }
    Poly operator*(Z a,Poly b) { return b*a; }
    Poly operator+=(Poly& a,const Poly& b) { return a=a+b; }
    Poly operator-=(Poly& a,const Poly& b) { return a=a-b; }
    template<class T>
    Poly operator*=(Poly& a,const T& b) { return a=a*b; }
    Poly Inv(const Poly& a,int m=-1) {
        assert(a[0].x!=0);
        if(m==-1) m=a.size();
        Poly f{a[0].inv()};
        int k=1;
        while(k<m) {
            k<<=1;
            f=modxk(f*(Poly{2}-f*modxk(a,k)),k);
            // 非MTT优化：两次变一次
            // Poly x=f; x.resize(k); x.resize(k<<1);
            // Poly y=a; y.resize(k); y.resize(k<<1);
            // dft(x), dft(y);
            // for(int i=0; i<x.size(); ++i)
            //     x[i]=x[i]*(2-x[i]*y[i]);
            // idft(x);
            // f=modxk(x,k);
        }
        return modxk(f,m);
    }
    namespace Cipolla {
        Z w,a;
        struct CP {
            Z x,y;
            CP(Z x,Z y): x(x),y(y) {}
            CP operator*(const CP& b) const{
                return CP(x*b.x+y*b.y*w,x*b.y+y*b.x);
            }
            CP pow(int b) const{
                CP ans(1,0), a(*this);
                for(; b; b>>=1,a=a*a)
                    if(b&1) ans=ans*a;
                return ans;
            }
        };
        int sqrt(Z n) {
            if(!n) return 0;
            if(power(n, (P-1)>>1).x==P-1)
                return -1;// 非二次剩余
            while(true) {
                a=rand(), w=a*a-n;
                if(power(w, (P-1)>>1).x==P-1)
                    return CP(a,1).pow((P+1)>>1).x.x;
            }
            return -1;
        }
    }
    Poly Sqrt(const Poly& a,int m=-1) {
        int x=Cipolla::sqrt(a[0]);
        assert(x!=-1);
        if(m==-1) m=a.size();
        Poly f{min(x,P-x)};
        int k=1;
        while(k<m) {
            k<<=1;
            f=(f+modxk(modxk(a,k)*Inv(f,k),k))*((1+P)>>1);
        }
        return modxk(f,m);
    }
    Poly Deriv(Poly a) {
        for(int i=0; i+1<a.size(); ++i) a[i]=a[i+1]*(i+1);
        if(a.size()) a.pop_back();
        return a;
    }
    Poly Integ(Poly a) {
        a.push_back(0);
        for(int i=a.size()-1; i>0; --i) a[i]=a[i-1]/i;
        a[0]=0;
        return a;
    }
    Poly Ln(const Poly& a,int m=-1) {
        assert(a[0].x==1);
        if(m==-1) m=a.size();
        return modxk(Integ(Deriv(a)*Inv(a,m)),m);
    }
    Poly Exp(const Poly& a,int m=-1) {
        assert(a[0].x==0);
        if(m==-1) m=a.size();
        Poly f{1};
        int k=1;
        while(k<m) {
            k<<=1;
            f=modxk(f*(Poly{1}-Ln(f,k)+modxk(a,k)),k);
        }
        return modxk(f,m);
    }
    Poly Pow(const Poly& a,ll k,int m=-1) {
        if(m==-1) m=a.size();
        int i=0;
        while(i<a.size() && !a[i].x) i++;
        if(i==a.size()||i*k>=m) return Poly(m);
        Z val=power(a[i], k);// val*x^(ik)
        Poly b=divxk(a,i)*a[i].inv();
        return mulxk(Exp(k*Ln(b,m-i*k),m-i*k),i*k)*val;
    }
    Poly operator/(Poly a,Poly b) {
        if(a.size()<b.size()) return {};
        int i=0;
        while(!b[i]) i++;
        a=divxk(a,i);
        b=divxk(b,i);
        int sz=a.size()-b.size()+1;
        reverse(a.begin(),a.end());
        reverse(b.begin(),b.end());
        a=modxk(a*Inv(b,sz),sz);
        reverse(a.begin(),a.end());
        return a;
    }
    Poly operator%(const Poly& a,const Poly& b) {
        return modxk(a-(a/b)*b,b.size()-1);
    }
    Poly mulSub(const Poly& a,Poly b) {// 减法卷积
        if(b.empty()) return Poly();
        reverse(b.begin(), b.end());
        return divxk(a*b,b.size()-1);
    }
    Poly divide(const vector<Poly>& f, int l, int r) {
        if(l+1==r) return f[l];
        int mid=l+r>>1;
        return divide(f,l,mid) * divide(f,mid,r);
    }
    Poly divide(const vector<Poly>& f) {
        if(f.size()==0) return {};
        return divide(f, 0, f.size());
    }
} using namespace NTT;
```

## 多项式在字符串匹配中的应用
带通配符的字符串匹配，$O(7 * n\log n)$  
```cpp
vector<int> match(const string& s,const string& mode,
    char wildcard='*') {
    // s:匹配串, mode:模式串, wildcard:通配符
    // 返回值: mode从s[0,n-m]的某处开始匹配能否匹配成功
    int len=1, n=s.size(), m=mode.size();
    while(len<n+m-1)
        len<<=1;
    vector<Comp> A1(len),A2(len),A3(len),B1(len),B2(len),B3(len);
    for(int i=0; i<m; ++i) {
        int t=(mode[m-1-i]==wildcard?0:mode[m-1-i]-'a'+1);
        A1[i]=t, A2[i]=t*t, A3[i]=t*t*t;
    }
    for(int i=0; i<n; ++i) {
        int t=(s[i]==wildcard?0:s[i]-'a'+1);
        B1[i]=t, B2[i]=t*t, B3[i]=t*t*t;
    }
    dft(A1), dft(A2), dft(A3);
    dft(B1), dft(B2), dft(B3);
    for(int i=0; i<len; ++i)
        A1[i]=A3[i]*B1[i]+A1[i]*B3[i]-A2[i]*B2[i]*2;
    idft(A1);
    vector<int> status(n);
    for(int i=m-1; i<n; ++i) 
        status[i-m+1]=!(ll)(A1[i].a+0.5);
    return status;
}
```

匹配时某个位置某个字符的不匹配度，$O(k * n\log n)$
```cpp
vector<int> match(const string& s,const string& mode) {
    // s：匹配串，mode：模式串
    // 返回值：mode从s[0,n-m]的某处开始匹配共有几个位置出错
    int n=s.size(), m=mode.size();
    vector<int> err(n);
    for(char ch='a'; ch<='z'; ++ch) {
        Poly f(n),g(m);
        for(int i=0; i<n; ++i) f[i]=(s[i]==ch);
        for(int i=0; i<m; ++i) g[i]=(mode[i]!=ch);
        f=mulSub(f,g);
        for(int i=0; i<=n-m; ++i) err[i]+=f[i].x;
    }
    return err;
}
```

# Min25筛
```cpp
namespace Min25 {
    const int N=2e5+10;
    int z[N], p[N], pn, sqr, vn, id1[N], id2[N];
    ll n, val[N];
    inline int& id(ll i) { return i<=sqr?id1[i]:id2[n/i]; }
    void init(ll _n) {
        z[1]=1, n=_n, sqr=sqrt(n+0.5);
        for (int i=2; i<=sqr; ++i) {
            if (!z[i]) p[++pn]=i;
            for (int j=1; p[j]<=sqr/i; ++j) {
                z[i*p[j]]=1;
                if (i%p[j]==0) break;
            }
        }
        for(ll l=1; l<=n; l=n/(n/l)+1)
            val[++vn]=n/l, id(val[vn])=vn;
    }
    struct G { // 必须是i^k
        vector<int> g,s;
        G():g(vn+1),s(pn+1) {}
        void init(const function<int(ll)>& f,
            const function<int(ll)>& sumf) {// init(f(i^k),sumf(i^k))
            for(int i=1; i<=vn; ++i) g[i]=sub(sumf(val[i]),1);
            for(int j=1; j<=pn; ++j) {
                for(int i=1; i<=vn && p[j]<=val[i]/p[j]; ++i) {
                    int k=id(val[i]/p[j]);
                    g[i]=sub(g[i],mul(f(p[j]),sub(g[k],s[j-1])));
                }
                s[j]=add(s[j-1],f(p[j]));
            }
        }
        int operator()(ll n,int j) {
            return sub(g[id(n)],s[j]);
        }
    };
    int S(ll n,int j,const function<int(ll,int)>& ps,
    const function<int(ll,ll,ll)>& f) {// 1+S(n,1,g(n,j),f(p^e))
        int ans=ps(n,j-1);
        for(int k=j; k<=pn && p[k]<=n/p[k]; ++k)
            for(ll e=1,t=p[k],t1=t*p[k]; t1<=n; ++e,t=t1,t1*=p[k]) {
                int val=f(p[k],e,t), val1=f(p[k],e+1,t1);
                ans=add(ans,add(mul(val, S(n/t,k+1,ps,f)),val1));
            }
        return ans;
    }
    void solve() { //f(p^k)=p^k*(p^k-1)
        ll n;
        cin>>n;
        init(n);
        G g1,g2;
        int inv6=qmi(6,mod-2);
        g1.init([](ll p){return p%=mod,mul(p,p);},
                [&](ll n){return n%=mod,mul(n,mul(n+1,mul(n*2+1,inv6)));});
        g2.init([](ll p){return p%mod;},
                [](ll n){return n%=mod,n*(n+1)/2%mod;});
        int ans=S(n,1,[&](ll n,int j){
            return sub(g1(n,j),g2(n,j));
        },[](ll p,ll e,ll pe){
            pe%=mod;
            return mul(pe,sub(pe,1));
        });
        ans=add(ans,1);
        cout<<ans;
    };
}
```

# 快速沃尔什变换FWT
```cpp
namespace FWT {
    using T=Z;
    using Poly=vector<T>;
    void andFwt(Poly& a,int type) {
        for(int m=1,n=a.size(); m<n; m<<=1)
            for(int i=0; i<n; i+=m<<1)
                for(int j=0; j<m; ++j) {
                    T x=a[i+j], y=a[i+j+m];
                    a[i+j]=(type>0?x+y:x-y);
                }
    }
    void orFwt(Poly& a,int type) {
        for(int m=1,n=a.size(); m<n; m<<=1)
            for(int i=0; i<n; i+=m<<1)
                for(int j=0; j<m; ++j) {
                    T x=a[i+j], y=a[i+j+m];
                    a[i+j+m]=(type>0?y+x:y-x);
                }
    }
    void xorFwt(Poly& a,int type) {
        for(int m=1,n=a.size(); m<n; m<<=1)
            for(int i=0; i<n; i+=m<<1)
                for(int j=0; j<m; ++j) {
                    T x=a[i+j], y=a[i+j+m];
                    a[i+j]=x+y, a[i+j+m]=x-y;
                }
        if(type<0) for(auto& x:a) x/=a.size();
    }
    Poly op(Poly a,Poly b,void(*fwt)(Poly&,int)) {
        fwt(a,1),fwt(b,1);
        for(int i=0; i<a.size(); ++i) a[i]*=b[i];
        fwt(a,-1);
        return a;
    }
}
using namespace FWT;
```

## 子集卷积FST
```cpp
// h[k]=sum_{i&j=0,i|j=k}(p[i]*q[j])
Poly subset(const Poly& p,const Poly& q) {
    int n=__builtin_ctz(p.size());
    vector<Poly> a(n+1,Poly(1<<n)),b(a),c(a);
    for(int i=0; i<p.size(); ++i) a[__builtin_popcount(i)][i]=p[i];
    for(int i=0; i<q.size(); ++i) b[__builtin_popcount(i)][i]=q[i];
    for(int i=0; i<=n; ++i) orFwt(a[i],1),orFwt(b[i],1);
    for(int i=0; i<=n; ++i)
        for(int j=0; j<=i; ++j) 
            for(int k=0; k<p.size(); ++k)
                c[i][k]=add(c[i][k],mul(a[j][k],b[i-j][k]));
    for(int i=0; i<=n; ++i) orFwt(c[i],-1);
    Poly h(1<<n);
    for(int i=0; i<h.size(); ++i) h[i]=c[__builtin_popcount(i)][i];
    return h;
}
```

## 分治FWT
- $\prod(1+b_ix^{a_i})$ 异或卷积
```cpp
void trans(vector<Poly>& a) {
    for(int m=1,n=a[0].size(); m<n; m<<=1) 
        for(int i=0; i<n; i+=m<<1) {
            for(int j=0; j<m; ++j) {
                int p0=a[0][i+j], p1=a[1][i+j];
                int q0=a[0][i+j+m], q1=a[1][i+j+m];
                a[0][i+j]=add(mul(p0,q0),mul(p1,q1));
                a[0][i+j+m]=sub(mul(p0,q0),mul(p1,q1));
                a[1][i+j]=add(mul(p1,q0),mul(p0,q1));
                a[1][i+j+m]=sub(mul(p1,q0),mul(p0,q1));
            }
        }
}
Poly divideFwt(const vector<pair<int,int>>& q) {// 异或卷积(1+bx^a)
    vector<Poly> f(2,Poly(1<<17));
    f[0].assign(f[0].size(),1);
    for(auto [a,b]:q) {
        int t0=f[0][a], t1=f[1][a];
        f[0][a]=add(t0,mul(t1,b)), f[1][a]=add(t1,mul(t0,b));
    }
    trans(f);
    xorFwt(f[0],-1), xorFwt(f[1],-1);
    Poly g(f[0].size());
    for(int i=0; i<g.size(); ++i) g[i]=add(f[0][i],f[1][i]);
    return g;
}
```

# 常系数齐次线性递推
```cpp
// 求出 a 的递推式，O(n^2)
Poly BM(const Poly& a) {
    int failw=0;
    Z deltaj=0, deltai=0;
    Poly Rw,R;
    for(int i=0; i<a.size(); ++i) {
        deltai=a[i]-inner_product(R.begin(),R.end(),a.rbegin()+a.size()-i,Z());
        if(!deltai) continue;
        if(R.empty()) {
            failw=i;
            deltaj=deltai;
            R=Poly(i+1);
        }else {
            Z t=deltai/deltaj;
            Poly Rc=Rw*-t, R_(i-failw-1);
            R_.push_back(t);
            R_.insert(R_.end(),Rc.begin(),Rc.end());
            if(R.size()+failw < Rw.size()+i) {
                Rw=R;
                failw=i;
                deltaj=deltai;
            }
            R=R+R_;
        }
    }
    return R;
}
// 根据递推式R求出 a 的 第 n 项，O(k*logk*logn)
Z getval(const Poly& a,const Poly& R,ll n) {
    if(n<a.size()) return a[n];
    int k=R.size();
    Poly G(k+1,1),H(1,1),T{0,1};
    for(int i=0; i<k; ++i)
        G[i]=-R[k-1-i];
    for(; n; n>>=1,T=T*T%G)
        if(n&1) H=H*T%G;
    Z ans=0;
    for(int i=0; i<H.size(); ++i)
        ans+=H[i]*a[i];
    return ans;
}
```

# 群论

## 圆环涂色计数
给一串项链的每个珠子涂一种颜色，旋转之后相同的项链算重复，求总涂色方案数。
```cpp
int n,m;
// 题目可能还有额外约束，此时修改calc()函数即可
int calc(int x) {
    // n个珠子形成环，涂色格式为1,2,..,x, 1,2,..,x,..的方案数
    return qmi(m,x);
}
int ans;
int x[70],cnt[70],xn;
void dfs(int idx,int d,int phi) {
    if(idx>xn) {
        ans+=calc(n/d)*phi;
        return;
    }
    for(int i=0; i<=cnt[idx]; ++i) {
        dfs(idx+1,d,phi);
        d*=x[idx];
        phi*=(i?x[idx]:x[idx]-1);
    }
}
void solve() {
    xn=0;
    int t=n;
    for(int i=2; i<=t/i; ++i) {
        if(t%i) continue;
        x[++xn]=i;
        cnt[xn]=0;
        while(t%i==0) {
            cnt[xn]++;
            t/=i;
        }
    }
    if(t>1) {
        x[++xn]=t;
        cnt[xn]=1;
    }
    ans=0;
    dfs(1,1,1);
    cout<<ans/n<<'\n';
}
```

## 置换和轮换
置换(排列)满足每个节点出度等于1且出点互不相同，形成了若干个环
```cpp
namespace Permutation {
    // 轮换c=(c0,c1,..) 表示a[c0] <- a[c1], a[c1] <- a[c2],..
    // 置换p=(p0,p1,..) 表示a[0] <- a[p0], a[1] <- a[p1],..
    // 置换 <-> 多个互不相交的轮换
    using Cycle=vector<int>;
    // 对a进行c轮换
    void applyC(vector<int>& a,const Cycle& c) {
        if(c.size()<=1) return;
        int a0=a[c[0]];
        for(int i=0; i+1<c.size(); ++i)
            a[c[i]]=a[c[i+1]];
        a[c.back()]=a0;
    }
    // 对a进行p置换
    void applyP(vector<int>& a,const vector<int>& p) {
        assert(a.size()==p.size());
        vector<int> b(a.size());
        for(int i=0; i<b.size(); ++i)
            b[i]=a[p[i]];
        a.swap(b);
    }
    // 互不相交的轮换 <- 置换
    vector<Cycle> PertoCycle(const vector<int>& p) {
        vector<Cycle> re;
        vector<int> vis(p.size());
        for(int i=0; i<p.size(); ++i) {
            if(vis[i]) continue;
            Cycle c{i};
            vis[i]=1;
            for(int j=p[i]; j!=i; j=p[j]) {
                c.push_back(j);
                vis[j]=1;
            }
            re.push_back(c);
        }
        return re;
    }
    // 置换 <- 互不相交的轮换
    vector<int> CycletoPer(const vector<Cycle>& c,int n) {
        vector<int> p(n);
        iota(p.begin(),p.end(),0);
        for(auto& g:c)
            applyC(p,g);
        return p;
    }
    // 轮换c的k次乘积，会分解成 gcd(k,size(c)) 个轮换
    // 轮换c的k次乘积，这里要满足 gcd(k,size(c))=1，结果还是一个轮换
    Cycle powerC0(const Cycle& c,int k) {
        k%=c.size();
        Cycle q{c[0]};
        for(int i=k; i!=0; i=(i+k)%c.size())
            q.push_back(c[i]);
        return q;
    }
    // 轮换c的k次乘积，结果是gcd(k,size(c))个轮换
    vector<Cycle> powerC(const Cycle& c,int k) {
        k%=c.size();
        vector<Cycle> re;
        vector<int> vis(c.size());
        for(int i=0; i<c.size(); ++i) {
            if(vis[i]) continue;
            Cycle c1{c[i]};
            vis[i]=1;
            for(int j=(i+k)%c.size(); j!=i; j=(j+k)%c.size()) {
                c1.push_back(c[j]);
                vis[j]=1;
            }
            re.push_back(c1);
        }
        return re;
    }
    // 置换p的k次乘积
    vector<int> powerP(const vector<int>& p,int k) {
        vector<Cycle> c=PertoCycle(p),re;
        for(auto& g:c) {
            if(gcd(k,g.size())==1)
                re.push_back(powerC0(g,k));
            else
                for(auto&& each:powerC(g,k))
                    re.push_back(each);
        }
        return CycletoPer(re,p.size());
    }
    // 置换p的k次开方，x^k=p，当且仅当每个轮换满足 (k,size(c))=1 时有解，但是解不唯一；
    // 这里仅求出一个轮换大小不变的解 x0。还有些解x，在x^k中轮换大小被分解变小了
    bool sqrtP_k(const vector<int>& p,int k,vector<int>& q) {
        vector<Cycle> c=PertoCycle(p),re;
        for(auto& g:c) {
            if(g.size()==1) {
                re.push_back(g);
                continue;
            }
            int inv=inverse<int>(k,g.size());
            if(inv==-1) return false;
            re.push_back(powerC0(g,inv));
        }
        q=CycletoPer(re,p.size());
        return true;
    }
    // q的以p为底的对数, p^x=q, 所有解 x=r mod m
    bool logP(const vector<int>& p,const vector<int>& q,ll& r,ll& m) {
        r=0, m=1;
        for(auto&& g:PertoCycle(p)) {
            int d=-1, sz=g.size();
            for(int i=0; i<sz; ++i)
                if(p[g[0]]==q[g[i]])
                    d=i;
            if(d==-1)
                return false;
            for(int i=0; i<sz; ++i)
                if(p[g[i]]!=q[g[(i+d)%sz]])
                    return false;
            if(!excrt(r,m,d,sz))
                return false;
        }
        return true;
    }
}
```

## 基环森林
若每个节点出度为1但不保证出点互不相同，会形成内向基环森林
```cpp
// 以下代码用于找出基环森林的所有环
// vis[u]=0，说明第一次遇到 u
// vis[u]=1，有三种状态，inCyc=-1，0，1
// 分别表示 u在这一轮形成了环，u在之前遍历过且不在环上，u在之前遍历过且在环上
vector<int> vis(n), inCyc(n,-1);
for(int i=0; i<n; ++i) {
    for(int j=i; ; j=a[j]) {
        if(!vis[j]) {
            vis[j]=1;
            continue;
        }
        if(inCyc[j]==-1) {// 这一轮形成了环
            int len=1;// 环长
            inCyc[j]=1;
            for(int k=a[j]; k!=j; k=a[k]) {
                len++;
                inCyc[k]=1;
            }
        }
        break;
    }
    for(int k=i; inCyc[k]==-1; k=a[k])
        inCyc[k]=0;// 标记非环点
}
```

# 博弈论

## mex运算
```cpp
int mex(const vector<int>& a) {
    vector<int> vis(a.size()+1);
    for (int x:a)
        if (x<(int)a.size())
            vis[x]=1;
    int p=0;
    while (vis[p]) p++;
    return p;
}
```

## nim积
分治法求nim积
```cpp
namespace Nim {
    using ull = unsigned long long;
    ull nimp[256][256];
    ull mul(ull x,ull y,int len=32) {
        if(x<=1||y<=1) return x*y;// mul(x,y)=0 only if x=0|y=0
        if(len<=4 && nimp[x][y]) return nimp[x][y];
        ull x0=x>>len, x1=x^(x0<<len), y0=y>>len, y1=y^(y0<<len);
        ull xy1=mul(x1,y1,len>>1), xy0=mul(x0,y0,len>>1);
        ull xy=mul(x0^x1,y0^y1,len>>1);
        ull res=mul(xy0,1ull<<(len-1),len>>1)^xy1^((xy^xy1)<<len);
        if(len<=4) nimp[x][y]=nimp[y][x]=res;
        return res;
    }
    ull pow(ull a,ull b) {
        ull re=1;
        for(; b; b>>=1,a=mul(a,a))
            if(b&1) re=mul(re,a);
        return re;
    }
    ull inv(ull a) {
        ull b=0;
        for(int i=1; !b&&i<6; ++i)
            if(a < (1ull<<(1<<i)))
                b=(1ull<<(1<<i))-2;
        if(!b) b=(1ull<<63)*2-2;
        return pow(a,b);
    }
} using namespace Nim;
```

nim积的BSGS
```cpp
// BSGS 求解nimProduct下的 a^x=b
namespace Nim {
    constexpr ull A=(1ull<<63)*2-1;// x^(Fn-1)=1
    constexpr int prm[]={3,5,17,257,641,65537,6700417};// A=3*5*..
    // return x, a^x=b (0<=x<up), O(sqrt(up))
    int bsgs(ull a,ull b,int up) {
        if(b==1) return 0;
        int B=sqrt(up)+1;
        ull ri=1;
        unordered_map<ull,int> id;
        for(int i=0; i<B; ++i,ri=mul(ri,a))
            id[mul(ri,b)]=i;
        ull le=ri;
        for(int i=1; i<=B; ++i,le=mul(le,ri))
            if(id.count(le))
                return i*B-id[le];
        return -1;
    }
    template<class T>
    T exgcd(T a,T b,T& x,T& y) {// |x|<=|a|,|y|<=|b|
        if(!b) return x=1, y=0, a;
        T d=exgcd(b,a%b,x,y), t=x;
        x=y, y=t-a/b*y;
        return d;
    }
    using Type=__int128_t;// ull maybe error due to negative
    bool excrt(ull& a1, ull& m1, Type a2, Type m2) {
        Type x, y, gcd=exgcd((Type)m1, m2, x, y), dx=m2/gcd;
        if((a2-a1)%gcd) return false;
        x=((a2-a1)/gcd*x%dx+dx)%dx;
        a1+=m1*x, m1*=m2/gcd;
        return true;
    }
    // https://codeforces.com/contest/1310/problem/F
    // return x, a^x=b, O(6000*O(mul))
    bool bsgs6000(ull a,ull b,ull& x) {
        x=0;
        ull m=1;
        for(int p:prm) {
            int r=bsgs(pow(a,A/p),pow(b,A/p),p);
            if(r==-1 || !excrt(x,m,r,p))
                return false;
        }
        return true;
    }
}
```
