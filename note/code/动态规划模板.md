# 动态规划模板
- [动态规划模板](#动态规划模板)
- [数位dp](#数位dp)
- [换根dp](#换根dp)
- [slope trick](#slope-trick)

# 数位dp
十进制版  
[windy 数](https://www.luogu.com.cn/problem/P2657)  
计算区间内满足“数位上相邻两数之差>=2”的数的个数  
[易变数](https://www.acwing.com/problem/content/5274/)  
使用前缀1的个数进行记忆化而不是 `pre`
```cpp
int digit[20];
ll dp[20][10];
ll dfs(int p, int pre, bool lead, bool lim) {
    if(p==-1) return 1;
    if(!lead && !lim && dp[p][pre]!=-1) return dp[p][pre];
    ll ans=0;
    for(int i=0, up=(lim ? digit[p] : 9); i<=up; ++i) {
        if(!lead && abs(i-pre)<=1) continue;// 两个数位之差至少为 2
        ans += dfs(p-1, i, lead&&i==0, lim&&i==up);
    }
    if(!lead && !lim) dp[p][pre]=ans;
    return ans;
}
ll part(ll x) {
    if(x<0) return 0;
    int l=0;
    for(; x; x/=10)
        digit[l++]=x%10;
    memset(dp, -1, sizeof dp);
    return dfs(l-1, 0, 1, 1);
}
```

[二进制版](https://atcoder.jp/contests/abc117/tasks/abc117_d)  
$f(x)=\sum_{i=1}^n (x \oplus a_i)$，计算 $x \in [0,m],\max f(x)$
```cpp
int digit[71];
ll dp[70][2];
ll dfs(int p, int pre, bool lead, bool lim) {
    if(p==-1) return 0;
    if(!lead && !lim && dp[p][pre]!=-1) return dp[p][pre];
    ll ans=0;
    for(int i=0, up=(lim ? digit[p] : 1); i<=up; ++i) {
        ll add=(i==0 ? cnt[p] : n-cnt[p]) * (1ll<<p);// clac(p,i)
        ans=max(ans, add + dfs(p-1, i, lead&&i==0, lim&&i==up));
    }
    if(!lead && !lim) dp[p][pre]=ans;
    return ans;
}
ll part(ll x) {
    memset(digit, 0, sizeof digit);
    for(int l=0; x; x>>=1)
        digit[l++]=x&1;
    memset(dp, -1, sizeof dp);
    return dfs(62, 0, 1, 1);
}
```

# 换根dp
```cpp
void Link(int u, int v, int w=1) {// update from bottom to top
    // TODO u -> v
    dp[u]+=dp[v]+w;
}
void cut(int u, int v, int w=1) {// update from top to bottom
    // TODO u -\> v
    dp[u]-=dp[v]+w;
}
void dfs1(int u, int fa) {
    // TODO u是孤点，初始化u的所有属性
    dp[u].e[0]=1;
    for (int i=head[u]; ~i; i=edge[i].next) {
        int v=edge[i].t, w=edge[i].l;
        if (v!=fa) {
            dfs1(v,u);
            Link(u,v,w);
        }
    }
}
void dfs2(int u, int fa) {
    // TODO 统计u作为根节点的信息
    ans+=dp[u].e[0];
    for (int i=head[u]; ~i; i=edge[i].next) {
        int v=edge[i].t, w=edge[i].l;
        if (v!=fa) {
            cut(u,v,w);// u把v子树拆分出去
            Link(v,u,w);// v变成根节点
            dfs2(v,u);
            cut(v,u,w);
            Link(u,v,w);
        }
    }
}
```

# slope trick
[blog详细讲解](https://codeforces.com/blog/entry/77298)  
[视频讲解以及大批习题](https://www.youtube.com/watch?v=p8RxN6Y9OOA)
```cpp
constexpr ll inf = numeric_limits<ll>::max()/2;
struct slope_trick_concave {// 凹折线函数
    priority_queue<ll> ql;
    priority_queue<ll,vector<ll>,greater<>> qr;
    ll tagl,tagr;// 左右堆中斜率改变点的懒标记
    ll height;// 最低点高度
    slope_trick_concave(): tagl(0), tagr(0), height(0) {
        ql.push(-inf);
        qr.push(inf);
    }
    ll get_left() {
        return ql.top()+tagl;
    }
    ll get_right() {
        return qr.top()+tagr;
    }
    // f(x) = g(x) + |x-c|
    void add(ll c) {
        ll xl=get_left();
        ll xr=get_right();
        if(xl <= c && c <= xr) {
            ql.push(c-tagl);
            qr.push(c-tagr);
        }else if(c < xl) {
            height+=xl-c;
            qr.push(xl-tagr);
            ql.pop();
            ql.push(c-tagl);
            ql.push(c-tagl);
        }else {
            height+=c-xr;
            ql.push(xr-tagl);
            qr.pop();
            qr.push(c-tagr);
            qr.push(c-tagr);
        }
    }
    // g(x) = min_{y=x+low, x+high} f(y)
    void range_min(ll low, ll high) {
        tagl-=high;
        tagr-=low;
    }
    // g(x) = min_{y=-inf, x} f(y)
    void pref_min() {
        // tagr=0;// 无所谓
        while(qr.size()>1)
            qr.pop();
    }
};
```

Japanese
```cpp
template< typename T >
struct SlopeTrick {
  const T INF = numeric_limits< T >::max() / 3;
  T min_f;
  priority_queue< T, vector< T >, less<> > L;
  priority_queue< T, vector< T >, greater<> > R;
  T add_l, add_r;
private:
  void push_R(const T &a) {
    R.push(a - add_r);
  }
  T top_R() const {
    if(R.empty()) return INF;
    else return R.top() + add_r;
  }
  T pop_R() {
    T val = top_R();
    if(not R.empty()) R.pop();
    return val;
  }
  void push_L(const T &a) {
    L.push(a - add_l);
  }
  T top_L() {
    L.push(0);
    if(L.empty()) return -INF;
    return L.top() + add_l;
  }
  T pop_L() {
    T val = top_L();
    if(not L.empty()) L.pop();
    return val;
  }
  size_t size() {
    return L.size() + R.size();
  }
public:
  SlopeTrick() : min_f(0), add_l(0), add_r(0) {}
  struct Query {
    T lx, rx, min_f;
  };
  // return min f(x)
  Query query() const {
    return (Query) {top_L(), top_R(), min_f};
  }
  // f(x) += a
  void add_all(const T &a) {
    min_f += a;
  }
  // add \_
  // f(x) += max(a - x, 0)
  void add_a_minus_x(const T &a) {
    min_f += max(T(0), a - top_R());
    push_R(a);
    push_L(pop_R());
  }
  // add _/
  // f(x) += max(x - a, 0)
  void add_x_minus_a(const T &a) {
    min_f += max(T(0), top_L() - a);
    push_L(a);
    push_R(pop_L());
  }
  // add \/
  // f(x) += abs(x - a)
  void add_abs(const T &a) {
    add_a_minus_x(a);
    add_x_minus_a(a);
  }
  // \/ -> \_
  // f_{new} (x) = min f(y) (y <= x)
  void clear_right() {
    while(not R.empty()) R.pop();
  }
  // \/ -> _/
  // f_{new} (x) = min f(y) (y >= x)
  void clear_left() {
    while(not L.empty()) L.pop();
  }
  // \/ -> \_/
  // f_{new} (x) = min f(y) (x-b <= y <= x-a)
  void shift(const T &a, const T &b) {
    assert(a <= b);
    add_l += a;
    add_r += b;
  }
  // \/. -> .\/
  // f_{new} (x) = f(x - a)
  void shift(const T &a) {
    shift(a, a);
  }
  // L, R 被破坏
  T get(const T &x) {
    T ret = min_f;
    while(not L.empty()) {
      auto val = pop_L();
      ret += max(T(0), val - x);
      if(val == add_l) break;
    }
    // while(not R.empty()) {
    //   ret += max(T(0), x - pop_R());
    // }
    return ret;
  }
  void merge(SlopeTrick &st) {
    if(st.size() > size()) {
      swap(st.L, L);
      swap(st.R, R);
      swap(st.add_l, add_l);
      swap(st.add_r, add_r);
      swap(st.min_f, min_f);
    }
    while(not st.R.empty()) {
      add_x_minus_a(st.pop_R());
    }
    while(not st.L.empty()) {
      add_a_minus_x(st.pop_L());
    }
    min_f += st.min_f;
  }
  void print(){
    cout << "L:";
    while(!L.empty()) cout << " " << pop_L(); cout << '\n';
    cout << "R:";
    while(!R.empty()) cout << " " << pop_R(); cout << '\n';
  }
};
```