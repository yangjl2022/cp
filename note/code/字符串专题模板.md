# 字符串专题模板
- [字符串专题模板](#字符串专题模板)
- [字符串哈希](#字符串哈希)
- [Z函数](#z函数)
- [马拉车](#马拉车)

# 字符串哈希
```cpp
namespace str {
struct Z {
    static constexpr int P0 = 998244353, P1 = 1e9 + 7;
    int v0, v1;
    template<typename T>
    Z(T x = 0) : v0((x % P0 + P0) % P0), v1((x % P1 + P1) % P1) {}
    constexpr Z(int x, int y) : v0(x), v1(y) {}
    friend Z operator+(Z lhs, Z const& rhs) {
        if((lhs.v0 += rhs.v0) >= P0) lhs.v0 -= P0;
        if((lhs.v1 += rhs.v1) >= P1) lhs.v1 -= P1;
        return lhs;
    }
    friend Z operator-(Z lhs, Z const& rhs) {
        if((lhs.v0 -= rhs.v0) < 0) lhs.v0 += P0;
        if((lhs.v1 -= rhs.v1) < 0) lhs.v1 += P1;
        return lhs;
    }
    friend Z operator*(Z lhs, Z const& rhs) {
        lhs.v0 = 1ll * lhs.v0 * rhs.v0 % P0;
        lhs.v1 = 1ll * lhs.v1 * rhs.v1 % P1;
        return lhs;
    }
    bool operator==(Z const& o) const {
        return v0 == o.v0 and v1 == o.v1;
    }
    bool operator<(Z const& o) const {
        return v0 < o.v0 or v0 == o.v0 and v1 < o.v1;
    }
};

vector<Z> powz(1, 1);
vector<Z> hash(string const& s) {
    static constexpr Z base(114514, 1919810);
    while(powz.size() < s.size())
        powz.emplace_back(powz.back() * base);
    vector<Z> h(s.size()+1);
    for(int i=0; i<s.size(); ++i)
        h[i+1] = h[i] * base + s[i];
    return h;
}
Z substrZ(vector<Z> const& h, int l, int r) {
    return h[r+1] - h[l] * powz[r-l+1];
}
// return length of lcp(s0[l0:], s1[l1:])
int lcp(vector<Z> const& h0, vector<Z> const& h1, int l0, int l1) {
    int l = 0, r = min(h0.size() - 1 - l0, h1.size() - 1 - l1), ans = -1;
    while(l <= r) {
        int mid = (l + r) / 2;
        if(substrZ(h0, l0, l0+mid) == substrZ(h1, l1, l1+mid)) {
            ans = mid;
            l = mid+1;
        }else r = mid-1;
    }
    return ans + 1;
}

}// namespace str
```

# Z函数
```cpp
// z[i]表示 s 和 s[i:] 匹配的最大长度
vector<int> zfunc(const string &s) {
    int n=s.size();
    vector<int> z(n);
    for(int i=1,l=0,r=0;i<n;i++) {
        if(i<=r) z[i]=min(z[i-l],r-i+1);
        while(i+z[i]<n&&s[i+z[i]]==s[z[i]]) z[i]++;
        if(i+z[i]-1>r) l=i,r=i+z[i]-1;
    }
    z[0]=n;
    return z;
}
```

# 马拉车
```cpp
// from @tourist
template <typename T>
vector<int> manacher(const T &s) {
  int n = s.size();
  if(!n) return {};
  vector<int> res(2*n-1, 0);
  int l = -1, r = -1;
  for(int z=0; z < 2*n-1; ++z) {
    int i = (z+1)/2, j = z/2;
    int p = (i >= r ? 0 : min(r-i, res[2*(l+r)-z]));
    while(j+p+1 < n and i-p-1 >= 0 and s[j+p+1] == s[i-p-1]) p++;
    if(j+p > r) l = i-p, r = j+p;
    res[z] = p;
  }
  return res;
  // res[2 * i] = odd radius in position i
  // res[2 * i + 1] = even radius between positions i and i + 1
  // s = "abaa" -> res = {0, 0, 1, 0, 0, 1, 0}
  // in other words, for every z from 0 to 2 * n - 2:
  // calculate i = (z + 1) >> 1 and j = z >> 1
  // now there is a palindrome from i - res[z] to j + res[z]
  // (watch out for i > j and res[z] = 0)
}
```