# 图论专题模板

- [图论专题模板](#图论专题模板)
- [链式前向星建图](#链式前向星建图)
- [拓扑排序](#拓扑排序)
- [最短路](#最短路)
  - [Dijkstra](#dijkstra)
  - [Spfa](#spfa)
  - [Floyd](#floyd)
- [最小生成树](#最小生成树)
  - [Prim](#prim)
  - [Kruskal](#kruskal)
  - [Boruvka](#boruvka)
- [图匹配](#图匹配)
  - [二分图判定](#二分图判定)
  - [二分图最大匹配](#二分图最大匹配)
  - [二分图最优匹配](#二分图最优匹配)
  - [一般图最大匹配](#一般图最大匹配)
  - [二分图边染色](#二分图边染色)
- [连通性](#连通性)
  - [无向图](#无向图)
  - [有向图](#有向图)
  - [Kruskal重构树](#kruskal重构树)
  - [支配树](#支配树)
- [网络流](#网络流)
  - [最大流](#最大流)
  - [最小割树](#最小割树)
  - [最小费用最大流](#最小费用最大流)
- [欧拉图](#欧拉图)
- [最小环](#最小环)
- [三四元环计数](#三四元环计数)
- [极大团搜索算法](#极大团搜索算法)


# 链式前向星建图
```cpp
struct Enode {
    int next, t;
    int l;
} edge[int(2e6)+10];
int en, head[N];
void initGraph(int n) {
    fill_n(head, n+1, -1), en = 0;
}
template<class... T>
void addEdge(int x, int y, T... args){
    edge[en] = {head[x], y, args...};
    head[x] = en++;
}
```

# 拓扑排序
DAG上做状态转移
```cpp
/// @param func func(u,v): u -\> v
void topo(const vector<vector<int>>& g, function<void(int,int)> func) {
    int n=g.size();
    vector<int> in(n);
    for(int u=0; u<n; ++u)
        for(auto v:g[u])
            ++in[v];
    queue<int> q;
    for(int i=0; i<n; ++i)
        if(!in[i]) q.push(i);
    while(q.size()) {
        int u=q.front();
        q.pop();
        for(auto v:g[u]) {
            func(u,v);
            if(--in[v]==0)
                q.push(v);
        }
    }
}
```

# 最短路
## Dijkstra
$O(m \log m)$
```cpp
template<class T>
struct Dijkstra {
    static constexpr T inf=numeric_limits<T>::max();
    vector<vector<pair<int,T>>> g;
    vector<T> dis;
    Dijkstra(int n):g(n) {}
    void addEdge(int u,int v,T w) {
        g[u].emplace_back(v,w);
    }
    struct Node {
        int u;
        T dis;
        bool operator<(const Node& O)const {
            return dis>O.dis;
        }
    };
    void dij(int s) {
        priority_queue<Node> q;
        dis.assign(g.size(),inf);
        dis[s]=0;
        q.push({s, 0});
        while(q.size()) {
            auto [u,tdis]=q.top();
            q.pop();
            if(tdis>dis[u]) continue;
            for(auto [v,w]:g[u]) {
                if(tdis < dis[v]-w) {
                    dis[v]=tdis+w;
                    q.push({v, dis[v]});
                }
            }
        }
    }
};
```

## Spfa
平均 $O(10n)$，最坏 $O(nm)$
```cpp
template<class T>
struct SPFA {
    static constexpr T inf=numeric_limits<T>::max()/2;
    int n;
    vector<vector<pair<int,T>>> g;
    vector<T> dis;
    SPFA(int n):n(n),g(n) {}
    void addEdge(int u,int v,T w) {
        g[u].emplace_back(v,w);
    }
    bool spfa(int s) {
        vector<bool> vis(n);
        vector<int> cnt(n);
        dis.assign(n,inf), dis[s]=0;// 最长路dis初始化-inf
        queue<int> q;
        q.push(s), vis[s]=true;
        while(q.size()) {
            int u=q.front();
            q.pop(), vis[u]=false;
            for(auto [v,w]:g[u]) {
                if(dis[v] > dis[u]+w) {// 最长路改为 v<u+w
                    dis[v]=dis[u]+w;
                    if((cnt[v]=cnt[u]+1)>=n)
                        return false;
                    if(!vis[v])
                        q.push(v), vis[v]=true;
                }
            }
        }
        return true;
    }
};
```

## Floyd
```cpp
void floyd(vector<vector<int>>& dis) {
    int n = dis.size();
    for(int k=0; k<n; ++k)
        for(int i=0; i<n; ++i)
            for(int j=0; j<n; ++j) {
                if(i!=j and i!=k and j!=k 
                and dis[i][k] < inf and dis[k][j] < inf// 边权有负数必加
                and dis[i][j] > dis[i][k]+dis[k][j])
                    dis[i][j] = dis[i][k]+dis[k][j];
            }
}
// 同时记录方案数
void floyd(vector<vector<int>>& dis, vector<vector<Z>>& f) {
    int n = dis.size();
    for(int k=0; k<n; ++k)
        for(int i=0; i<n; ++i)
            for(int j=0; j<n; ++j)
                if(i!=j && i!=k && j!=k) {
                    if(dis[i][j] > dis[i][k]+dis[k][j]) {
                        dis[i][j] = dis[i][k]+dis[k][j];
                        f[i][i] = f[i][k] * f[k][j];
                    }else if(dis[i][j] == dis[i][k]+dis[k][j]) {
                        f[i][j] += f[i][k] * f[k][j];
                    }
                }
}
```

# 最小生成树
## Prim
$O(m \log m)$
```cpp
template<class T>
struct PrimMst {
    static constexpr T inf=numeric_limits<T>::max();
    int n;
    vector<vector<pair<int,T>>> g;
    vector<T> dis;
    vector<bool> vis;
    PrimMst(int n):n(n),g(n) {}
    void addEdge(int u,int v,T w) {
        g[u].emplace_back(v,w);
        g[v].emplace_back(u,w);
    }
    struct Node {
        int t;
        T len;
        bool operator<(const Node& O)const {
            return len>O.len;
        }
    };
    T prim() {
        dis.assign(n,inf);
        vis.assign(n,false);
        priority_queue<Node> q;
        q.push({0, 0});
        T ans=0;
        int cnt=0;
        while(q.size()) {
            auto [u,len]=q.top();
            q.pop();
            if(vis[u]) continue;
            vis[u]=true;
            ans+=len;
            if(++cnt >= n) break;
            for(auto [v,w]:g[u])
                if(!vis[v] && w<dis[v])
                    q.push({v, dis[v]=w});
        }
        // assert(cnt==n);
        return ans;
    }
};
```

## Kruskal
$O(m \log m)$
```cpp
template<class T>
struct KruskalMst {
    int n;
    vector<int> f;
    vector<tuple<T,int,int>> e;
    KruskalMst(int n):n(n),f(n) {}
    void addEdge(int u,int v,T w) {
        e.emplace_back(w,u,v);
    }
    int get(int u) {
        return f[u]==u?u: f[u]=get(f[u]);
    }
    T kruskal() {
        iota(f.begin(),f.end(),0);
        sort(e.begin(),e.end());
        T ans=0;
        int cnt=0;
        for(auto [w,u,v]:e) {
            if((u=get(u))==(v=get(v))) continue;
            f[u]=v;
            ans+=w;
            if(++cnt==n-1) break;
        }
        // assert(cnt==n-1);
        return ans;
    }
};
```

## Boruvka
```cpp
bool used[N];// used edge label
bool les(int i,int j) {// 边的偏序关系一定要固定
    if(j==-1) return true;
    if(edge[i].l != edge[j].l)
        return edge[i].l < edge[j].l;
    return i < j;
}
ll boruvka(int n) {// O(m log n)
    Dsu d(n+1);
    ll sum=0,num=0;
    while(true) {
        vector<int> eid(n+1,-1);
        for(int u=1; u<=n; ++u) {
            int s=d.get(u);
            for(int i=head[u]; ~i; i=edge[i].next) {
                int v=edge[i].t;
                if(s==d.get(v))
                    continue;
                if(les(i,eid[s]))
                    // !!! 注意是每个连通块保留一条最小边，不是每个点
                    eid[s]=i;
            }
        }
        bool updated=false;
        for(int u=1; u<=n; ++u) {
            if(eid[u]==-1) continue;
            int v=edge[eid[u]].t;
            if(!d.unite(u,v)) continue;
            used[eid[u]/2]=1;
            sum+=edge[eid[u]].l;
            updated=true;
            ++num;
        }
        if(!updated or num+1==n)
            break;
    }
    return num+1==n?sum:-1;
}
```

利用boruvka算法思想$O(n \log n \log n)$求解最小异或生成树
```cpp
ll dfs(int u=root, int wei=HIGH-1) {
    if(wei<0) return 0;
    ll ans=0;
    int lch=ch[u][0], rch=ch[u][1];
    if(lch)
        ans+=dfs(lch,wei-1);
    if(rch)
        ans+=dfs(rch,wei-1);
    if(lch&&rch) {
        int w=1<<30;
        // 左右子树之间的异或最小值
        for(int i=lid[lch]; i<=rid[lch]; ++i)
            w=min(w,(1<<wei)|query(a[i],rch,wei-1));
        ans+=w;
    }
    return ans;
}
ll xorMst() {
    sort(a+1,a+1+n);
    for(int i=1; i<=n; ++i) 
        ins(i);
    return dfs();
}
```

# 图匹配
## 二分图判定
$O(n)$
```cpp
struct JudgeBG {
    int n;
    vector<int> bel;// bel:1 or 2
    vector<vector<int>> g;
    JudgeBG(int n): n(n),g(n),bel(n) {}
    void addEdge(int u,int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    bool dfs(int u, int color=1) {
        if(bel[u])
            return bel[u]==color;
        bel[u]=color;
        for(int v:g[u])
            if(!dfs(v, 3-color))
                return false;
        return true;
    }
    bool paint() {// 二分图染色
        for(int i=0; i<n; ++i) {
            if(bel[i]) continue;
            if(!dfs(i)) return false;
        }
        return true;
    }
    // vector<int> to;//[0,ln), [0,rn)
    // //  use it to divide the graph if paint()=true
    // BipartiteGraph reLabel() {// left->right
    //     int ln=0,rn=0;
    //     to.resize(n);
    //     for(int i=0; i<n; ++i) {
    //         if(bel[i]==1)
    //             to[i]=ln++;
    //         else
    //             to[i]=rn++;
    //     }
    //     BipartiteGraph bg(ln,rn);
    //     for(int i=0; i<n; ++i)
    //         for(int j:g[i])
    //             if(bel[i]==1)
    //                 bg.addEdge(to[i],to[j]);
    //     return bg;
    // }
};
```

## 二分图最大匹配
匈牙利算法O(n*m)
```cpp
struct BipartiteGraph {
    int n,m;
    vector<vector<int>> g;
    vector<int> vis,link;
    BipartiteGraph(int n,int m):n(n),m(m),g(n),vis(m),link(m) {}
    void addEdge(int u,int v) {// left->right
        g[u].push_back(v);
    }
    bool find(int u) {// 左边u -> 右边v
        for(int v:g[u]) {
            if(vis[v]) continue;
            vis[v]=1;
            if(link[v]==-1 || find(link[v])) {
                link[v]=u;
                return true;
            }
        }
        return false;
    }
    int maxMatching() {
        int cnt=0;
        fill_n(link.begin(),m,-1);
        for(int i=0; i<n; ++i) {
            if(!find(i)) continue;
            fill_n(vis.begin(),m,0);
            ++cnt;
        }
        return cnt;
    }
};
```

HK算法复杂度：O(E*sqrt(V))
```cpp
struct HopcroftKarp {// index-0, O(sqrt(n)*m)
    static constexpr int INF = 0x3f3f3f3f;
    int n,m,dis;
    vector<vector<int>> e;
    vector<int> matchX,matchY,dx,dy;
    vector<bool> used;
    HopcroftKarp(int n,int m)
    :n(n),m(m),e(n),matchX(n),matchY(m),dx(n),dy(m),used(m) {}
    void addEdge(int u,int v) {// left->right
        e[u].push_back(v);
    }
    bool searchP(){
        fill(dx.begin(),dx.end(),-1);
        fill(dy.begin(),dy.end(),-1);
        dis = INF;
        queue<int> q;
        for(int i=0; i<n; ++i) 
            if(matchX[i] == -1)
                q.push(i), dx[i] = 0;
        while(!q.empty()) {
            int u = q.front(); q.pop();
            if(dx[u] > dis) break;
            for(int v:e[u])
                if(dy[v] == -1) {
                    dy[v] = dx[u] + 1;
                    if(matchY[v] == -1) dis = dy[v];
                    else dx[matchY[v]] = dy[v] + 1, q.push(matchY[v]);
                }
        }
        return dis != INF;
    }
    bool dfs(int u){
        for(int v:e[u]) {
            if(used[v] || dy[v]!=dx[u]+1) continue;
            used[v] = true;
            if(matchY[v] != -1 && dy[v] == dis) continue;
            if(matchY[v] == -1 || dfs(matchY[v])) {
                matchY[v] = u;
                matchX[u] = v;
                return true;
            }
        }
        return false;
    }
    int maxMatching(){
        int res = 0;
        fill(matchX.begin(),matchX.end(),-1);
        fill(matchY.begin(),matchY.end(),-1);
        while(searchP()) {
            fill(used.begin(),used.end(),false);
            for(int i=0; i<n; ++i) 
                if(matchX[i] == -1 && dfs(i))
                    ++res;
        }
        return res;
    }
};
```

## 二分图最优匹配
bfs找增广路，复杂度$O(n^3)$
```cpp
struct Kuhn_Munkers {// index-1, O(n^3)
    using T=int;
    static constexpr int N = 1000 + 5;
    static constexpr T INF = numeric_limits<T>::max()>>1;
    T e[N][N], lx[N], ly[N], slack[N];
    int n, matchNum, matchX[N], matchY[N], pre[N];
    bool vis[N];
    // 默认边权为-INF，求出的是最大匹配，在此基础之上追求权值和最大
    // e0=0，求出的是最大权匹配，只追求权值和最大
    void init(int n,T e0=-INF) {
        this->n=n;
        for(int i=1; i<=n; ++i) fill(e[i],e[i]+1+n,e0);
    }
    void addEdge(int u,int v,T w) {
        e[u][v]=max(e[u][v],w);
    }
    void bfs(int u) {
        fill(slack,slack+1+n,INF);
        fill(pre,pre+1+n,0);
        int x, y=0, yy=0;
        T a;
        matchY[y]=u;
        for(;;) {
            x = matchY[y]; a = INF, vis[y] = true;
            for(int i=1; i<=n; ++i) if(!vis[i]) {
                if(slack[i]+e[x][i] > lx[x]+ly[i]) {// 细节防止溢出
                    slack[i] = lx[x]+ly[i]-e[x][i];
                    pre[i] = y;
                }
                if(slack[i] < a) a=slack[i],yy = i;
            }
            for(int i=0; i<=n; ++i) {
                if(vis[i]) lx[matchY[i]] -= a, ly[i] += a;
                else slack[i] -= a;
            }
            y = yy;
            if(!matchY[y]) break;
        }
        while(y) matchY[y] = matchY[pre[y]], y = pre[y];
    }
    T KM() {
        fill(lx,lx+1+n,0);
        fill(ly,ly+1+n,0);
        fill(matchY,matchY+1+n,0);
        for(int i=1; i<=n; ++i) {
            fill(vis,vis+1+n,false);
            bfs(i);
        }
        T ans = matchNum = 0;
        for(int j=1; j<=n; ++j)
            if(e[matchY[j]][j]>-INF) {// 通过-INF判断是否存在边
                matchX[matchY[j]]=j;
                ans += e[matchY[j]][j];
                ++matchNum;
            } else {
                // return INF;// 没有匹配上
                matchX[matchY[j]]=0;
                matchY[j]=0;
            }
        return ans;
    }
} g;
```

左右节点数不同的板子，from [tourist](https://codeforces.com/contest/1955/submission/255672975)
```cpp
template <typename T>
class hungarian {
 public:
  int n;
  int m;
  vector<vector<T>> a;
  vector<T> u;
  vector<T> v;
  vector<int> pa;
  vector<int> pb;
  vector<int> way;
  vector<T> minv;
  vector<bool> used;
  T inf;
 
  hungarian(int _n, int _m) : n(_n), m(_m) {
    assert(n <= m);
    a = vector<vector<T>>(n, vector<T>(m));
    u = vector<T>(n + 1);
    v = vector<T>(m + 1);
    pa = vector<int>(n + 1, -1);
    pb = vector<int>(m + 1, -1);
    way = vector<int>(m, -1);
    minv = vector<T>(m);
    used = vector<bool>(m + 1);
    inf = numeric_limits<T>::max();
  }
 
  inline void add_row(int i) {
    fill(minv.begin(), minv.end(), inf);
    fill(used.begin(), used.end(), false);
    pb[m] = i;
    pa[i] = m;
    int j0 = m;
    do {
      used[j0] = true;
      int i0 = pb[j0];
      T delta = inf;
      int j1 = -1;
      for (int j = 0; j < m; j++) {
        if (!used[j]) {
          T cur = a[i0][j] - u[i0] - v[j];
          if (cur < minv[j]) {
            minv[j] = cur;
            way[j] = j0;
          }
          if (minv[j] < delta) {
            delta = minv[j];
            j1 = j;
          }
        }
      }
      for (int j = 0; j <= m; j++) {
        if (used[j]) {
          u[pb[j]] += delta;
          v[j] -= delta;
        } else {
          minv[j] -= delta;
        }
      }
      j0 = j1;
    } while (pb[j0] != -1);
    do {
      int j1 = way[j0];
      pb[j0] = pb[j1];
      pa[pb[j0]] = j0;
      j0 = j1;
    } while (j0 != m);
  }
 
  inline T current_score() {
    return -v[m];
  }
 
  inline T solve() {
    for (int i = 0; i < n; i++) {
      add_row(i);
    }
    return current_score();
  }
};
```


## 一般图最大匹配
```cpp
struct Blossom {// O(n^3)
    int n, vis_t;
    vector<vector<int>> E;
    vector<int> match, label, org, vis, parent;
    queue<int> Q;
    Blossom(int n):n(n),E(n),match(n,-1),label(n),org(n),
        parent(n,-1),vis(n),vis_t(0) {
        iota(org.begin(), org.end(), 0);
    }
    void addEdge(int u, int v) {
        E[u].emplace_back(v);
        E[v].emplace_back(u);
    }
    int lca(int v, int u) {
        vis_t++;
        while (true) {
            if (v != -1) {
                if (vis[v] == vis_t)
                    return v;
                vis[v] = vis_t;
                if (match[v] == -1)
                    v = -1;
                else
                    v = org[parent[match[v]]];
            }
            swap(v, u);
        }
    }
    void agument(int v) {
        while (v != -1) {
            int pv = parent[v];
            int nxt = match[pv];
            match[v] = pv;
            match[pv] = v;
            v = nxt;
        }
    }
    void flower(int v, int u, int a) {
        while (org[v] != a) {
            parent[v] = u;
            u = match[v];
            if (label[u] == 1) {
                label[u] = 0;
                Q.emplace(u);
            }
            org[v] = org[u] = a;
            v = parent[u];
        }
    }
    bool bfs(int root) {
        fill(label.begin(), label.end(), -1);
        iota(org.begin(), org.end(), 0);
        while (!Q.empty())
            Q.pop();
        Q.emplace(root);
        label[root] = 0;
        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for (int v : E[u]) {
                if (label[v] == -1) {
                    label[v] = 1;
                    parent[v] = u;
                    if (match[v] == -1) {
                        agument(v);
                        return true;
                    }
                    label[match[v]] = 0;
                    Q.push(match[v]);
                    continue;
                } else if (label[v] == 0 && org[v] != org[u]) {
                    int a = lca(org[u], org[v]);
                    flower(v, u, a);
                    flower(u, v, a);
                }
            }
        }
        return false;
    }
    int maxMatching() {
        for (int i = 0; i < n; ++i)
            if (match[i] == -1)
                bfs(i);
        return (n-count(match.begin(),match.end(),-1))/2;
    }
};
```


## 二分图边染色
$O(nm)$ 对二分图的边染色，相邻边不同色
```cpp
// index-1
int n;
int eid[N][N];
void edgeColoring() {
    for(int i=1; i<=n; ++i)
        memset(eid[i], -1, sizeof eid[i]);
    for(int u=1; u<=n; ++u) {
        for(int i=head[u]; ~i; i=edge[i].next) {
            int v=edge[i].t;
            if(edge[i].l) continue;
            int cu = find(eid[u]+1, eid[u]+n+1, -1) - eid[u];
            int cv = find(eid[v]+1, eid[v]+n+1, -1) - eid[v];
            if(cu != cv) {// cu,cv,..->cv,cu,..
                int cuv = cu^cv;
                vector<int> path;
                for(int c = min(cu, cv), x = cu<cv ? v : u; ; c^=cuv) {
                    int j = eid[x][c];
                    if(!~j) break;
                    path.push_back(j);
                    x = edge[j].t;
                }
                for(bool fr=true; path.size(); path.pop_back()) {
                    int j = path.back();
                    if(fr) fr=false, eid[edge[j].t][edge[j].l]=-1;
                    int temp = edge[j].l ^ cu ^ cv;
                    edge[j].l = edge[j^1].l = temp;
                    eid[edge[j^1].t][temp] = j;
                    eid[edge[j].t][temp] = j^1;
                }
            }
            int temp = min(cu, cv);
            edge[i].l = edge[i^1].l = temp;
            eid[u][temp] = i, eid[v][temp] = i^1;
        }
    }
}
```

# 连通性
## 无向图
边连通分量 $O(n+m)$
```cpp
struct Tarjan {
    int n,dn,bn,index;
    vector<vector<pair<int,int>>> g;
    vector<vector<int>> ecc;
    vector<int> dfn,low,bel;
    stack<int> st;
    Tarjan(int n):n(n),dn(0),bn(0),index(0),g(n),dfn(n),low(n),bel(n) {}
    void addEdge(int u,int v) {
        g[u].emplace_back(v,index++);
        g[v].emplace_back(u,index++);
    }
    void tarjan(int u,int index) {
        dfn[u]=low[u]=++dn;
        st.push(u);
        for(auto [v,i]:g[u]) {
            if((i^1)==index)// 防止立马回头
                continue;
            if(!dfn[v]) {
                tarjan(v,i);
                low[u]=min(low[u], low[v]);
                // if(dfn[u]<low[v]) {}// 割边
            }else {
                low[u]=min(low[u], dfn[v]);// 返祖边
            }
        }
        if(dfn[u]==low[u]) {
            vector<int> cur;
            for(int v=-1; v!=u; ) {
                v=st.top();
                st.pop();
                bel[v]=bn;
                cur.push_back(v);// 连通分量的信息
            }
            ecc.emplace_back(cur);
            bn++;
        }
    }
    void converge() {
        for(int i=0; i<n; ++i)
            if(!dfn[i]) tarjan(i,-1);
    }
    auto newForest() {
        vector<vector<int>> tr(bn);
        for(int u=0; u<n; ++u)
            for(auto [v,i]:g[u])
                if(bel[u]!=bel[v])
                    tr[bel[u]].push_back(bel[v]);
        return tr;
    }
};
```

点连通分量 $O(n+m)$
```cpp
struct Tarjan {
    int n,dn,rt;
    vector<vector<int>> g;
    vector<vector<int>> vcc;
    vector<int> dfn,low,cut;
    stack<int> st;
    Tarjan(int n):n(n),dn(0),g(n),dfn(n),low(n),cut(n) {}
    void addEdge(int u,int v) {
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    void tarjan(int u) {
        dfn[u]=low[u]=++dn;
        st.push(u);
        int chd=0;
        for(int v:g[u]) {
            if(!dfn[v]) {
                tarjan(v);
                low[u]=min(low[u], low[v]);
                if(dfn[u]<=low[v]) {
                    if(u!=rt||++chd>1) cut[u]=1;// 割点
                    vcc.push_back({u});
                    for (int x=-1; x!=v; st.pop())
                        vcc.back().push_back(x=st.top());
                }
            }else {// 返祖边
                // 求vcc判不判回头边无所谓
                low[u]=min(low[u], dfn[v]);
            }
        }
        if(u==rt&&chd==0)// 孤点
            vcc.push_back({u});
    }
    void converge() {
        for(rt=0; rt<n; ++rt) 
            if(!dfn[rt]) tarjan(rt);
    }
    // 圆方树/森林
    auto newForest() {
        vector<vector<int>> tr(n+vcc.size());// 注意孤点影响
        for(int i=0; i<vcc.size(); ++i)
            for(int x:vcc[i]) {
                tr[n+i].push_back(x);// 方点向圆点连边
                tr[x].push_back(n+i);
            }
        return tr;
    }
};
```

## 有向图
$Tarjan$ 算法求强连通分量 $O(n+m)$
```cpp
struct Tarjan {
    int n,dn,bn;
    vector<vector<int>> g;
    vector<int> dfn,low,insta,bel;
    stack<int> st;
    Tarjan(int n):n(n),dn(0),bn(0),g(n),dfn(n),low(n),insta(n),bel(n) {}
    void addEdge(int u,int v) {
        g[u].push_back(v);
    }
    void tarjan(int u) {
        dfn[u]=low[u]=++dn;
        st.push(u), insta[u]=1;
        for(int v:g[u]) {
            if(!dfn[v]) {
                tarjan(v);
                low[u]=min(low[u], low[v]);
            }else if(insta[v])// 返祖边和横插边
                low[u]=min(low[u], dfn[v]);
        }
        if(dfn[u]==low[u]) {
            for(int v=-1; v!=u; ) {
                v=st.top();
                insta[v]=0, st.pop();
                bel[v]=bn;
                // sum[bn]+=a[v];// 连通分量的信息
            }
            bn++;
        }
    }
    void converge() {
        for(int i=0; i<n; ++i)
            if(!dfn[i]) tarjan(i);
    }
    auto newDAG() {
        vector<vector<int>> graph(bn);
        for(int u=0; u<n; ++u)
            for(int v:g[u])
                if(bel[u]!=bel[v])
                    graph[bel[u]].push_back(bel[v]);
        return graph;
    }
};
```

$Kosaraju$ 算法求强连通分量 $O(n+m)$
```cpp
struct Kosaraju {
    int n,belNum;
    vector<vector<int>> g,rg;
    vector<int> popS,vis,bel;
    Kosaraju(int n): n(n),belNum(0),g(n),rg(n),vis(n),bel(n) {}
    void addEdge(int u,int v) {
        g[u].push_back(v);
        rg[v].push_back(u);
    }
    void dfs1(int u) {
        vis[u]=1;
        for(int v:g[u])
            if(!vis[v]) dfs1(v);
        popS.push_back(u);
    }
    void dfs2(int u) {
        vis[u]=0;
        bel[u]=belNum;
        // sum[belNum]+=a[u];
        for(int v:rg[u])
            if(vis[v]) dfs2(v);
    }
    void converge() {
        for(int i=0; i<n; ++i)
            if(!vis[i]) dfs1(i);
        for(; popS.size(); popS.pop_back())
            if(vis[popS.back()]) {
                dfs2(popS.back());
                ++belNum;
            }
    }
    auto newDAG() {
        vector<vector<int>> graph(belNum);
        for(int u=0; u<n; ++u)
            for(int v:g[u])
                if(bel[u]!=bel[v])
                    graph[bel[u]].push_back(bel[v]);
        return graph;
    }
};
```

## Kruskal重构树
```cpp
namespace krt {// index-1
    constexpr int N = 1e5 * 2 + 10, LOG = __lg(N);// 开节点数的两倍
    using EType = int;// 边权类型
    constexpr bool ASC = true;// 边权从小到大排序
    int n, nn, f[LOG+1][N];
    EType val[N];
    vector<int> g[N];
    int sq[N], sn, L[N], R[N];
    void build(int n, vector<tuple<EType,int,int>> e) {
        assert(n*2 < N);
        nn = krt::n = n;
        fill_n(g, n*2, vector<int>());
        vector<int> rt(n*2);// [1, 2*n-1]
        iota(rt.begin(), rt.end(), 0);
        function<int(int)> get = [&](int u) {
            return rt[u] == u ? u : rt[u] = get(rt[u]);
        };
        if constexpr(ASC) sort(e.begin(), e.end());
        else sort(e.begin(), e.end(), greater());
        for(auto& [w,u,v]:e) {
            if((u = get(u)) == (v = get(v))) continue;
            val[++nn] = w;
            f[0][v] = f[0][u] = rt[u] = rt[v] = nn;
            g[nn].push_back(u);
            g[nn].push_back(v);
        }
        // 预处理倍增数组
        for(int i=1; i<=LOG; ++i)
            for(int u=1; u<=nn; ++u)
                f[i][u] = f[i-1][f[i-1][u]];
        // 处理 dfs 序（只有叶子拥有序号）
        sn = 0;
        function<void(int)> dfs = [&](int u) {
            L[u] = sn+1;
            if(u <= n) sq[++sn] = u;
            for(int v:g[u]) dfs(v);
            R[u] = sn;
        };
        for(int i=1; i<=nn; ++i)
            if(!f[0][i]) dfs(i);
    }
    // 在lim的限制下最高能跳到哪一个节点
    int jumpUp(int u, EType lim) {
        for(int i=LOG; i>=0; --i) {
            if constexpr (ASC) {
                if(f[i][u] and val[f[i][u]]<=lim) u = f[i][u];
            }else {
                if(f[i][u] and val[f[i][u]]>=lim) u = f[i][u];
            }
        }
        return u;
    }
}
```

## 支配树
Lengauer-Tarjan算法求解一般有向图的支配树$O(n*\alpha(n,m))$
```cpp
struct DominatorTree {// index-1
    static const int N = 2e5 + 10;
    int n, s;
    vector<int> g[N], rg[N], trS[N], trI[N];
    int pos[N], dfn[N], dn;
    int f0[N], fa[N], mn[N];
    int sdom[N], idom[N];
    void init(int _n,int _s=1) {
        n=_n, s=_s, dn=0;
        for(int i=1; i<=n; ++i) {
            g[i].clear();
            rg[i].clear();
            trS[i].clear();
            trI[i].clear();
            dfn[i]=0;
            fa[i]=mn[i]=sdom[i]=i;
        }
    }
    void addEdge(int u,int v) {
        g[u].push_back(v);
        rg[v].push_back(u);
    }
    // 默认s号节点可以到达其他所有节点
    void buildTree() {
        dfs(s);
        for(int i=dn; i>1; --i) {
            int u=pos[i], idx=n+10;
            for(int v:rg[u]) {
                if(dfn[v]<dfn[u])
                    idx=min(idx,dfn[v]);
                else {
                    find(v);
                    idx=min(idx,dfn[sdom[mn[v]]]);
                }
            }
            sdom[u]=pos[idx];
            fa[u]=f0[u];
            trS[sdom[u]].push_back(u);
            u=f0[u];
            for(int v:trS[u]) {
                find(v);
                idom[v] = (sdom[mn[v]]==u ? u : mn[v]);
            }
            trS[u].clear();
        }
        for(int i=2; i<=dn; ++i) {
            int u=pos[i];
            if(idom[u]!=sdom[u])
                idom[u]=idom[idom[u]];
            trI[idom[u]].push_back(u);
        }
    }
    int sz[N];
    void dfs_sz(int u) {
        sz[u]=1;
        for(int v:trI[u]) {
            dfs_sz(v);
            sz[u]+=sz[v];
        }
    }
private:
    void dfs(int u) {
        pos[dfn[u]=++dn]=u;
        for(int v:g[u])
            if(!dfn[v]) {
                dfs(v);
                f0[v]=u;
            }
    }
    int find(int u) {
        if(fa[u]==u) return u;
        int old=fa[u];
        fa[u]=find(fa[u]);
        if(dfn[sdom[mn[old]]] < dfn[sdom[mn[u]]])
            mn[u]=mn[old];
        return fa[u];
    }
} dom;
```

# 网络流

## 最大流
$O(n^2m)$
```cpp
namespace net {
    using T = long long;
    constexpr T INF = numeric_limits<T>::max()/2;
    constexpr int _V = 2e5 + 10;
    constexpr int _E = 2e6 + 10;
    int s0, t0, _n, head[_V], dis[_V], to[_E], nxt[_E], en;
    T fl[_E];
    void initGraph(int n = _V-2) {
        _n = n, s0 = _n++, t0 = _n++, en = 0, fill_n(head, _n, -1);
    }
    void addEdge(int x, int y, T z) {
        assert(x<_V && y<_V), assert(en+1<_E);
        to[en] = y, nxt[en] = head[x], fl[en] = z, head[x] = en++;
        to[en] = x, nxt[en] = head[y], fl[en] = 0, head[y] = en++;
    }
    bool bfs(int s,int t) {
        fill_n(dis, _n, -1);
        queue<int> q;
        q.push(s), dis[s]=0;
        while(q.size()) {
            int u=q.front();
            q.pop();
            for (int i=head[u]; ~i; i=nxt[i])
                if(dis[to[i]]==-1 && fl[i]>0)
                    q.push(to[i]), dis[to[i]] = dis[u]+1;
        }
        return dis[t] != -1;
    }
    T dfs(int u, int t, T flow) {
        if(u==t) return flow;
        T ans = flow;
        for (int i=head[u]; ~i && ans; i=nxt[i]) {
            int v = to[i];
            if (dis[v] == dis[u]+1 && fl[i]>0) {
                T temp=dfs(v, t, min(fl[i], ans));
                fl[i] -= temp;
                fl[i^1] += temp;
                ans -= temp;
            }
        }
        if(ans == flow) dis[u] = -1;
        return flow - ans;
    }
    T dinic(int s,int t) {
        T ans=0;
        while(bfs(s,t)) ans += dfs(s, t, INF);
        return ans;
    }
}
```

输出路径用下面的函数
```cpp
// 只保留最大流图，边权为流过的流量
void shrink(bool abandonST=false) {
    for(int u=0; u<_V; ++u) {
        if(abandonST && u==s0) {
            head[u]=-1;
            continue;
        }
        int* p=&head[u];
        for(int i=head[u]; ~i; ) {
            int v=edge[i].t;
            if((i&1)||edge[i^1].l==0|| (abandonST&&v==t0) ) {
                i=*p=edge[i].next;
            }else {
                edge[i].l=edge[i^1].l;
                p=&edge[i].next;
                i=*p;
            }
        }
    }
}
// 在shrink()之后，找到u的下一个节点，同时删边
int findNext(int u) {
    int &h=head[u];
    if(h==-1)
        return -1;
    int v=edge[h].t;
    if(--edge[h].l==0)
        h=edge[h].next;
    return v;
}
```

输出图结构
```cpp
void printGraph() {
    #ifndef YJL
    return;
    #endif
    auto dot=[&](int u)->string{
        if(u==s0) return "S";
        if(u==t0) return "T";
        return to_string(u);
    };
    cerr << endl << "Graph with " << en << " edges:" << endl;
    for(int i=0; i<en; i+=2) {
        cerr << dot(to[i^1]) << " -> " << dot(to[i]) <<" : ";
        cerr << (fl[i]==INF ? "INF" : to_string(fl[i])) << endl;
    }
}
```

## 最小割树
求解任意两节点之间的最小割 $O(n^3m)$
```cpp
int ge[210][210];
void divide(const vector<int>& a) {
    if(a.size()==1) return;
    for(int i=0; i<en; i+=2) {// 退流
        edge[i].l+=edge[i^1].l;
        edge[i^1].l=0;
    }
    int flow=dinic(a[0],a[1]);
    vector<int> b1,b2;
    for(int x:a) {
        if(dis[x]!=-1) b1.push_back(x);// 与S连通的点集
        else b2.push_back(x);
    }
    divide(b1);
    divide(b2);
    // 最小割树上：x-> a[0] -> a[1] -> y
    for(int x:b1)
        for(int y:b2)
            ge[x][y]=ge[y][x]=min({ge[x][a[0]],flow,ge[a[1]][y]});
}
void solve(int n) {
    memset(ge,0x3f,sizeof ge);
    vector<int> a(n);
    iota(a.begin(),a.end(),1);
    divide(a);
}
```

## 最小费用最大流
$O(nmf)$
```cpp
namespace NetFlow {
    using T = int;
    const T INF = numeric_limits<T>::max()/2;
    const int _V = 10000 + 10;
    const int _E = 200000 * 2 + 10;
    int _n, s0, t0, head[_V], en;
    struct EDGE {
        int t, next;
        T f, cost;
    } edge[_E];
    void initGraph(int n = _V-2) {
        _n = n, s0 = _n++, t0 = _n++, en = 0, fill_n(head, _n, -1);
    }
    void addEdge(int x, int y, T f, T cost) {
        assert(x<_V && y<_V), assert(en<_E);
        edge[en]= {y, head[x], f, cost}, head[x]=en++;
        edge[en]= {x, head[y], 0, -cost}, head[y]=en++;
    }
    T dis[_V], incf[_V];
    int vis[_V], pre[_V];
    bool spfa(int s,int t) {
        queue<int> q;
        fill_n(dis, _n, INF);
        dis[s]=0;
        incf[s]=INF;
        pre[t]=-1;
        q.push(s);
        while(q.size()) {
            int u=q.front();
            q.pop();
            vis[u]=0;
            for(int i=head[u]; ~i; i=edge[i].next) {
                int v=edge[i].t;
                if(dis[u]+edge[i].cost<dis[v] && edge[i].f>0) {
                    dis[v]=dis[u]+edge[i].cost;
                    incf[v]=min(incf[u], edge[i].f);
                    pre[v]=i;
                    if (!vis[v]) {
                        q.push(v);
                        vis[v]=1;
                    } 
                }
            }
        }
        return pre[t]!=-1;
    }
    T maxf, fee;
    void minCostMaxFlow(int s,int t) {
        maxf=fee=0;
        while(spfa(s,t)) {
            int u=t;
            while(u!=s) {
                int i=pre[u];
                edge[i].f-=incf[t];
                edge[i^1].f+=incf[t];
                u=edge[i^1].t;
            }
            maxf+=incf[t];
            fee+=incf[t]*dis[t];
        }
    }
}
using namespace NetFlow;
```

dijstra版本
```cpp
namespace NetFlow {
    using T=int;
    constexpr T INF=numeric_limits<T>::max()/2;
    constexpr int _V = 5e3 + 10;
    constexpr int _E = 1e6 * 2 + 10;// 双向边
    int _n, s0, t0;
    int head[_V], en, pre[_V];
    int to[_E], nxt[_E];
    T fl[_E], cost[_E], dis[_V], incf[_V], he[_V], maxf, fee;
    void initGraph(int n = _V-2) {
        _n = n, s0 = _n++, t0 = _n++, en = 0, fill_n(head, _n, -1);
    }
    void addEdge(int x, int y, T f, T Cost) {
        assert(x<_V && y<_V), assert(en+1<_E);
        to[en]=y, nxt[en]=head[x], fl[en]=f, cost[en]=Cost, head[x]=en++;
        to[en]=x, nxt[en]=head[y], fl[en]=0, cost[en]=-Cost, head[y]=en++;
    }
    bool dij(int s,int t) {
        using pii=pair<T,int>;
        priority_queue<pii,vector<pii>,greater<>> q;
        fill_n(dis, _n, INF);
        dis[s]=0, incf[s]=INF, pre[t]=-1;
        q.push({dis[s], s});
        while(q.size()) {
            auto [td, u]=q.top();
            q.pop();
            if(td > dis[u]) continue;
            for(int i=head[u]; ~i; i=nxt[i]) {
                int v=to[i];
                if(fl[i]>0 && dis[v]+he[v] > dis[u]+cost[i]+he[u]) {
                    dis[v] = dis[u]+cost[i]+he[u]-he[v];
                    incf[v]=min(incf[u], fl[i]), pre[v]=i;
                    q.push({dis[v], v});
                }
            }
        }
        return pre[t]!=-1;
    }
    void minCostMaxFlow(int s, int t) {
        maxf = fee = 0, fill_n(he, _n, 0);
        while(dij(s,t)) {
            for(int u=t; u!=s; ) {
                int i=pre[u];
                fl[i]-=incf[t];
                fl[i^1]+=incf[t];
                u=to[i^1];
            }
            maxf += incf[t];
            fee += incf[t]*(dis[t]+he[t]);
            for(int i=0; i<_n; ++i)
                he[i] += dis[i];// 更新势能
        }
    }
}
using namespace NetFlow;
```

输出图结构
```cpp
void printGraph() {
    auto dot=[&](int u)->string{
        if(u==s0) return "S";
        if(u==t0) return "T";
        return to_string(u);
    };
    cerr<<endl<<"Graph with "<<en<<" edges:"<<endl;
    for(int i=0; i<en; ++i) {
        int u=edge[i^1].t, v=edge[i].t;
        T flow=edge[i].f, cost=edge[i].cost;
        cerr<<dot(u)<<" -> "<<dot(v)<<" : ";
        cerr<<(flow==INF?"INF":to_string(flow))<<" , ";
        cerr<<(cost==INF?"INF":to_string(cost))<<endl;
    }
    #ifdef ONLINE_JUDGE
    #define printGraph()0
    #endif
}
```

源汇点数量及其不平衡的模拟费用流板子 [例题](https://contest.ucup.ac/contest/1356/problem/7185)
```cpp
//  m源n汇，m*n条流量为1，花费为cost[i][j]的边，n个汇点容量为capa[j]
//  求最小费用最大流 O(m n^3 + m n^2 log m)
//  assert m <= \sum_v capa[v]，必要时补一个容量为 m 的汇点
namespace mcbm {
    using Cost = int;// 单条边的花费
    using Total = long long;// 总花费
    constexpr int MAX_M = 100'000;
    constexpr int MAX_N = 10;
    constexpr Cost COST_INF = 1001001001;
    int m, n;// m, n, capa, cost需要初始化, index-0
    int capa[MAX_N];
    Cost cost[MAX_M][MAX_N + 1];
    int to[MAX_M];
    Cost slopes[MAX_M];
    priority_queue<pair<Cost, int>, vector<pair<Cost, int>>, greater<>> cisss[MAX_N + 1][MAX_N];
    Cost adj[MAX_N + 1][MAX_N], dist[MAX_N];
    int prv[MAX_N];
    bool on[MAX_N];
    int que[MAX_N * MAX_N], * qb, * qe;
    Total run() {
        for (int u = 0; u <= n; ++u)
            for (int v = 0; v < n; ++v)
                cisss[u][v] ={};
        for (int i = 0; i < m; ++i) {
            cost[i][to[i] = n] = 0;
            for (int v = 0; v < n; ++v)
                cisss[n][v].emplace(cost[i][v], i);
        }
        Total total = 0;
        for (int flow = 0; flow < m; ++flow) {
            for (int u = 0; u <= n; ++u)
                for (int v = 0; v < n; ++v) {
                    auto& cis = cisss[u][v];
                    for (; !cis.empty() && to[cis.top().second] != u; cis.pop()) {}
                    adj[u][v] = cis.empty() ? COST_INF : cis.top().first;
                }
            qb = qe = que;
            for (int v = 0; v < n; ++v) {
                dist[v] = adj[n][v]; prv[v] = n;
                on[*qe++ = v] = true;
            }
            for (; qb != qe; ) {
                const int u = *qb++;
                on[u] = false;
                for (int v = 0; v < n; ++v) {
                    const Cost cc = dist[u] + adj[u][v];
                    if (dist[v] > cc) {
                        dist[v] = cc; prv[v] = u;
                        if (!on[v]) on[*qe++ = v] = true;
                    }
                }
            }
            int vm = -1;
            for (int v = 0; v < n; ++v)
                if (capa[v] > 0) {
                    if (!~vm || dist[vm] > dist[v]) vm = v;
                }
            // Failure means m > \sum_v capa[v]
            assert(~vm);
            total += slopes[flow] = dist[vm];
            --capa[vm];
            for (int v = vm; v != n; ) {
                const int u = prv[v];
                const int i = cisss[u][v].top().second;
                for (int w = 0; w < n; ++w)
                    if (v != w) {
                        cisss[v][w].emplace(cost[i][w] - cost[i][v], i);
                    }
                to[i] = v; v = u;
            }
        }
        return total;
    }
}  // namespace mcbm
```

# 欧拉图
有向图求欧拉通路/回路 $O(n+m)$
```cpp
struct DirectEulerGraph {
    int n,en;
    vector<vector<pair<int,int>>> g;
    vector<int> in;
    DirectEulerGraph(int n):n(n),en(0),g(n),in(n) {}
    void addEdge(int u,int v) {
        g[u].emplace_back(v,en++);
        ++in[v];
    }
    vector<int> path;// 存欧拉路
    vector<int> idx;
    void dfs(int u,int eid=-1) {
        while(idx[u]<g[u].size()) {
            auto [v,i]=g[u][idx[u]++];
            dfs(v,i);
        }
        if(eid!=-1)
            path.emplace_back(eid);
    }
    bool findEulerPath() {
        int s=-1,t=-1,flag=0;
        for(int i=0; i<n; ++i) {
            int d=in[i]-(int)g[i].size();
            if(in[i]) flag=i;
            if(d>1||d<-1) return false;
            if(!d) continue;
            if(d==1 && t==-1) t=i;
            else if(d==-1 && s==-1) s=i;
            else return false;
        }
        if(s!=-1 || t!=-1) return false;// 要的是欧拉回路，而不是欧拉通路时
        if(s==-1) s=flag;// 所有点in=out，随意找一个有边的
        path.clear();
        idx.assign(n,0);
        dfs(s);
        if(path.size()!=en) return false;// 图不连通
        reverse(path.begin(),path.end());
        return true;
    }
};
```

无向图求欧拉通路/回路
```cpp
struct UndirectEulerGraph {
    int n,en;
    vector<vector<pair<int,int>>> g;
    UndirectEulerGraph(int n):n(n),g(n),en(0) {}
    void addEdge(int u,int v) {
        g[u].emplace_back(v,en++);
        g[v].emplace_back(u,en++);
    }
    vector<int> path;
    vector<int> idx;
    vector<bool> vis;
    void dfs(int u,int eid=-1) {
        while(idx[u]<g[u].size()) {
            auto [v,i]=g[u][idx[u]++];
            if(vis[i]) continue;
            vis[i]=vis[i^1]=true;
            dfs(v,i);
        }
        if(eid!=-1)
            path.emplace_back(eid);
    }
    bool findEulerPath() {
        int s=-1,t=-1,flag=-1;
        for(int i=0; i<n; ++i) {
            if(g[i].size() && !~flag) flag=i;
            if(g[i].size()&1) {
                if(s==-1) s=i;
                else if(t==-1) t=i;
                else return false;
            }
        }
        if(s!=-1) return false;// 要的是欧拉回路，而不是欧拉通路时
        if(s==-1) s=flag;
        path.clear();
        idx.assign(n,0);
        vis.assign(en,false);
        fill(idx.begin(),idx.end(),0);
        dfs(s);
        if(path.size()!=en/2) return false;// 边不连通
        reverse(path.begin(),path.end());
        return true;
    }
};
```

# 最小环
$floyd$求最小环$O(n^3)$
```cpp
const int inf=0x3f3f3f3f;
struct MinCircle {
    static const int N = 100 + 10;
    int n, e[N][N], dis[N][N];
    void init(int _n) {
        n=_n;
        for(int i=1; i<=n; ++i)
            for(int j=1; j<=n; ++j)
                e[i][j]=(i^j?inf:0);
    }
    void addEdge(int u,int v,int w) {
        if(e[u][v]>w) e[u][v]=w;
    }
    int minCircle() {
        int ans=inf;
        memcpy(dis,e,sizeof e);
        for(int k=1; k<=n; ++k) {
            for(int i=1; i<=n; ++i)
                if(i!=k && e[i][k]!=inf)
                    for(int j=1; j<=n; ++j)
                        if(j!=k && j!=i && e[k][j]!=inf && dis[j][i]!=inf)
                            ans=min(ans,e[i][k]+e[k][j]+dis[j][i]);
            for(int i=1; i<=n; ++i)
                for(int j=1; j<=n; ++j)
                    if(i!=j && i!=k && j!=k)
                        dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        }
        return ans;
    }
} mc;
```

断边$dijkstra$求最小环$O(m^2\log m)$
```cpp
const int inf=0x3f3f3f3f;
struct MinCircle {
    static const int N = 4000 + 10;
    static const int M = 2e6 + 10;
    struct ty {
        int t,l,next;
    } edge[M];
    int n, ans;
    int en, head[N];
    void initGraph(int _n) {
        n=_n;
        en=0;
        fill_n(head+1,n,-1);
    }
    void addEdge(int x,int y,int z=0) {
        edge[en]={y,z,head[x]};
        head[x]=en++;
        edge[en]={x,z,head[y]};// 无向图
        head[y]=en++;
    }
    int dis[N];
    void dij(int s,int t,int broken) {
        for(int i=1; i<=n; ++i)
            dis[i]=(s^i?inf:0);
        using pii=pair<int,int>;
        priority_queue<pii> q;
        q.emplace(0,s);
        while(q.size()) {
            auto [d,u]=q.top();
            q.pop();
            d=-d;
            if(u==t) break;
            if(d+broken>=ans) break;
            if(d>dis[u]) continue;
            for(int i=head[u]; ~i; i=edge[i].next) {
                if(ban[i]) continue;
                int v=edge[i].t;
                auto w=edge[i].l;
                if(dis[v]>dis[u]+w) {
                    dis[v]=dis[u]+w;
                    q.emplace(-dis[v],v);
                }
            }
        }
    }
    bool ban[M];
    int minCircle() {
        ans=inf;
        for(int u=1; u<=n; ++u)
            for(int i=head[u]; ~i; i=edge[i].next) {
                int v=edge[i].t;
                auto w=edge[i].l;
                ban[i]=true;
                ban[i^1]=true;// 无向图
                dij(v,u,w);
                ans=min(ans,w+dis[u]);
                ban[i]=false;
                ban[i^1]=false;// 无向图
            }
        return ans;
    }
} mc;
```

SCFA求有向图最小环 $O(nm\log m)$，并且可以求方案数
```cpp
const ll inf=1e18;
struct SCFA {// index-1
    struct Node {
        int u;
        ll dis;
        bool operator<(const Node& O)const {
            return dis>O.dis;
        }
    };
    static const int N = 500 + 10;
    int n;
    vector<pair<int,int>> g[N];
    void initGraph(int _n) {
        n=_n;
        for(int i=1; i<=n; ++i)
            g[i].clear();
    }
    void addEdge(int u,int v,int w) {
        g[u].emplace_back(v,w);
    }
    void findMinCircle() {
        minCir=inf, num=0;
        for(int s=1; s<=n; ++s)
            dij(s);
    }
    ll dis[N], minCir;// 最小环大小
    Z f[N], num;// 最小环方案数
private:
    void dij(int s) {
        priority_queue<Node> q;
        fill_n(dis+1,n,inf);
        dis[s]=0;
        f[s]=1;
        q.push({s, 0});
        int flag=1;
        while(q.size()) {
            auto [u,tdis]=q.top();
            q.pop();
            if(tdis>dis[u]) continue;
            for(auto [v,w]:g[u]) {
                if(v<s) continue;// 保证s最小
                if(tdis < dis[v]-w) {
                    dis[v]=tdis+w;
                    f[v]=f[u];
                    q.push({v, dis[v]});
                }else if(tdis==dis[v]-w) {
                    f[v]+=f[u];
                }
            }
            if(u==s) {
                if(flag) {
                    dis[s]=inf;
                    flag=0;
                }else {
                    if(dis[s]<minCir) {
                        minCir=dis[s];
                        num=f[s];
                    }else if(dis[s]==minCir) {
                        num+=f[s];
                    }
                }
            }
        }
    }
} scfa;
```


# 三四元环计数
复杂度 $O(m \sqrt m)$
```cpp
int circle3(const vector<vector<int>> &og) {// og是简单无向图
    int n=og.size();
    vector<basic_string<int>> g(n);
    for(int i=0; i<n; ++i) {
        for(int j:og[i])
            if(i<j) {
                if(og[i].size()>og[j].size())
                    g[i]+=j;
                else
                    g[j]+=i;
            }
    }
    int ans=0;
    vector<int> vis(n,-1);
    for(int i=0; i<n; ++i) {
        for(int j:g[i])
            vis[j]=i;
        for(int j:g[i])
            for(int k:g[j])
                ans+=vis[k]==i;
    }
    return ans;
}
ll circle4(const vector<vector<int>> &g) {// g是简单无向图
    int n=g.size();
    auto gre=[&](int i,int j) {
        if(g[i].size()!=g[j].size())
            return g[i].size()>g[j].size();
        return i>j;
    };
    ll ans=0;
    vector<int> c(n),vis(n),st;
    for(int i=0; i<n; ++i) {
        for(int j:g[i])
            if(gre(i,j))
                for(int k:g[j])
                    if(gre(i,k)) {
                        ans+=c[k]++;
                        if(!vis[k]) {
                            vis[k]=1;
                            st.push_back(k);
                        }
                    }
        for(; st.size(); st.pop_back()) {
            c[st.back()]=0;
            vis[st.back()]=0;
        }
    }
    return ans;
}
```

# 极大团搜索算法
[Bron-Kerbosch算法找极大团，n=130，47ms](http://poj.org/problem?id=2989)
```cpp
int n, g[N][N];
int all[N][N], some[N][N], none[N][N];// R,P,X
int ans;
void BronKerbosch(int an,int sn,int nn) {
    if(!sn && !nn) ++ans;// 一个极大团 [all[an],all[an]+an)
    int u=some[an][0];// an既是层数，也是R集合大小
    for(int i=0; i<sn; ++i) {
        int v=some[an][i];
        if(i && g[u][v]) continue;// 关键点的邻居
        memcpy(all[an+1],all[an],sizeof(int)*an);
        all[an+1][an]=v;// R+{v}
        int tsn=0,tnn=0;
        for(int j=0; j<sn; ++j)
            if(g[v][some[an][j]])
                some[an+1][tsn++]=some[an][j];
        for(int j=0; j<nn; ++j)
            if(g[v][none[an][j]])
                none[an+1][tnn++]=none[an][j];
        BronKerbosch(an+1,tsn,tnn);
        some[an][i]=0;// R-={v}
        none[an][nn++]=v;// X+={v}
        // if(ans>1000) return;
    }
}
void maximalClique() {
    ans=0;
    for(int i=0; i<n; ++i)
        some[0][i]=i+1;
    BronKerbosch(0,n,0);
}
```

[找最大团，n=50，10ms](https://vjudge.net/problem/ZOJ-1492)
```cpp
int n, g[N][N];
int num[N], ans;
bool dfs(int adj[],int an,int cnt) {
    if(!an && cnt>ans) {
        ans=cnt;
        return true;// 剪枝：1~i的最大团被更新后，不再找其他最大团，直接返回
    }
    for(int i=0; i<an; ++i) {
        if(cnt+num[adj[i]] <= ans)// 剪枝：1~adj[i]最多加入 num[adj[i]] 个
            return false;
        if(cnt+an-i <= ans)// 剪枝：后面最多加入 an-i 个
            return false;
        int adj2[N], an2=0;// P & Neighbors{v}
        for(int j=i+1; j<an; ++j)
            if(g[adj[i]][adj[j]])
                adj2[an2++]=adj[j];
        if(dfs(adj2,an2,cnt+1))
            return true;
    }
    return false;
}
void maximalClique() {
    ans=0;
    for(int i=1; i<=n; ++i) {
        int adj[N],an=0;// 小于i的可能与i构成最大团的节点
        for(int j=i-1; j>=1; --j)
            if(g[i][j])
                adj[an++]=j;
        dfs(adj,an,1);
        num[i]=ans;// 只考虑1~i能构成的最大团
    }
}
```