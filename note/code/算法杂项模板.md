# 算法杂项模板
- [算法杂项模板](#算法杂项模板)
- [树的直径](#树的直径)
- [Python高精度Decimal](#python高精度decimal)
- [Java高精度整数BigInteger](#java高精度整数biginteger)
- [Java高精度浮点数BigDecimal](#java高精度浮点数bigdecimal)
- [Python时间日期类](#python时间日期类)
- [Pbds库](#pbds库)
  - [红黑树](#红黑树)
  - [块状链表](#块状链表)
  - [哈希表](#哈希表)
  - [字典树](#字典树)
  - [可合并堆](#可合并堆)
- [随机数](#随机数)
- [HashMap](#hashmap)
- [Xor Shift](#xor-shift)
- [程序运行计时](#程序运行计时)
- [手动开栈](#手动开栈)
- [模拟退火](#模拟退火)
- [快读快写](#快读快写)

# 树的直径
树形 $DP$
```cpp
int dis[N], len = -INF;
void dfs(int u, int fa) {
    for (auto [v, w]:g[u]) {
        if(v == fa) continue;
        dfs(v, u);
        len = max(len, dis[u]+dis[v]+w);
        dis[u] = max(dis[u], dis[v]+w);
    }
}
```

两次 $dfs$
```cpp
int pv[N], d[N];
int len, X;// 找到最远的点X
void dfs(int u, int fa, int dis) {
    if(dis >= len) X = u, len = dis;
    for (auto [v, w]:g[u]) {
        if(v==fa) continue;
        pv[v] = u, d[v] = w;
        dfs(v, u, dis+w);
    }
}
```

# Python高精度Decimal
python基于NTT的高精度a*b
```python
import decimal
decimal.getcontext().prec = 200000
a=decimal.Decimal(input())
b=decimal.Decimal(input())
print(a*b)
#a的b次方也可以快速计算,a**b
```

# Java高精度整数BigInteger 
```java
String temp1 = "-1000000000000000000000000000000000000";
BigInteger a = new BigInteger(temp1);// 使用字符串初始化
String temp2 = "100000000000000000000000000";
BigInteger b = new BigInteger(temp2);
// |a|, a+b, a-b, a*b, a/b, a%b, gcd(a,b), 
a.abs(); a.add(b); a.subtract(b); a.multiply(b); a.divide(b);  a.mod(b); a.gcd(b);
// power(a, 1000), 注意这里的幂的类型是普通 int
a.pow(1000);
// cmp函数，a-b ? 0 来决定 1,-1,0
a.compareTo(b);
// 判断两数相等
a.equals(b);        
```

# Java高精度浮点数BigDecimal
```java
String temp1 = "1.2222222222222222222222222";
BigDecimal bd1 = new BigDecimal(temp1);
String temp2 = "2.333333333333333333333333";
BigDecimal bd2 = new BigDecimal(temp2);
bd1.add(bd2);// 加法 输出 3.5555555555555555555555552
bd1.add(bd2).doubleValue();//输出 3.5555555555555554
bd2.subtract(bd1);         //减法 输出 1.1111111111111111111111108
bd2.multiply(bd1);         //乘法 输出 2.851851851851...
//除法应该注意很有可能会有除不尽的情况，这时候会有异常抛出，所以要传入控制参数
bd2.divide(bd1, 5, RoundingMode.HALF_UP);
// 对于浮点数大小关系的判断，使用 compareTo() 会判断浮点误差
BigDecimal bd3 = new BigDecimal("1.20");
BigDecimal bd4 = new BigDecimal("1.2");
bd3.compareTo(bd4);        //返回0表示相等
bd3.equals(bd4);           //返回的是false  !!!是错误的
//注意用scale调整位数避免超时
BigDecimal a = BigDecimal.valueOf(0.14521);
BigDecimal b = BigDecimal.valueOf(0.721351);
a.scale();// a的位数 5
BigDecimal c = a.setScale(2, BigDecimal.ROUND_HALF_DOWN);// 0.15
a.divide(b, 3, BigDecimal.ROUND_HALF_DOWN);// 0.201
```

# Python时间日期类
日期时间datetime模块
```python
# 1.date：日期对象(常用属性year,month,day)
# Gregorian数与日期的转换
a = datetime.date(2023, 9, 10)
a.toordinal()  # 返回Gregorian数，即公元公历开始到现在的天数（公元1年1月1日为1）
datetime.date.fromordinal(a.toordinal())  # 将Gregorian数转化为date对象
# 星期几
a.weekday() # 0-6
# 格式化输出时间
a.strftime("%Y/%m/%d")  # '2023/09/10'

# 2.time：时间对象(hour, minute, second, microsecond, tzinfo)
a = datetime.time(11, 7, 59, 899)
a.strftime('%H:%M:%S')

# 3.datetime：日期时间对象(hour,minute,second,microsecond)
# 根据string, format 2个参数，返回一个对应的datetime对象
datetime.datetime.strptime('2023-9-10 11:23', '%Y-%m-%d %H:%M')
# 4.timedelta：用来计算两个datetime对象的差值的
```

日历模块calendar
```python
calendar.isleap(2008)  # True：2008年为闰年
calendar.leapdays(2008, 2011)  # 1：返回 [y1,y2) 之间的闰年数量
# 按周来划分一个月，不在该月的用0表示：[[0, 0, 0, 0, 1, 2, 3], [4,..],...[..,0]]
calendar.monthcalendar(2023, 9)
```

# Pbds库
## 红黑树
与 $std::set$ 的区别：
- 支持通过排名找节点，通过值找排名
- $tr.begin()$ 的前驱是 $tr.end()$
```cpp
// #include<bits/extc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using pii = pair<int, int>;
using Tree =  tree<pii, null_type, less<pii>, rb_tree_tag,
    tree_order_statistics_node_update>;
Tree tr;
Tree::iterator Pos(int x) { return tr.lower_bound({x, -1}); }
tr.insert({x, i++});// 插入多重值的技巧
tr.erase(Pos(x));
tr.order_of_key(*Pos(x));// 返回排名，从0开始
tr.find_by_order(x);// 第x小的元素的迭代器，x从0开始
prev(Pos(x));// 前驱
Pos(x+1);// 后继
```

## 块状链表
区间翻转
```cpp
#include <ext/rope>
template<typename T>
struct ReversableArray {
    int n;
    __gnu_cxx::rope<T> ro, iro;// [0,n-1]
    // a = [0, 1, ..., num-1]
    ReversableArray(int num) : n(num) {
        for(int i=0; i<n; ++i) ro.push_back(i), iro.push_front(i);
    }
    ReversableArray(vector<T> const& a) : n(a.size()) {
        for(int i=0; i<n; ++i) ro.push_back(a[i]), iro.push_front(a[i]);
    }
    void reverse(int l, int r) {// [l,r]
        if(l>r) return;
        auto as = ro.substr(l, r-l+1);
        auto bs = iro.substr(n-1-r, r-l+1);
        ro.erase(l, r-l+1);
        iro.erase(n-1-r, r-l+1);
        ro.insert(l, bs.begin(), bs.end());
        iro.insert(n-r-1, as.begin(), as.end());
    }
};
```


## 哈希表
```cpp
#include <ext/pb_ds/hash_policy.hpp>
__gnu_pbds::cc_hash_table<int,int> mp1;//拉链法
__gnu_pbds::gp_hash_table<int,int> mp2;//查探法(快一些)
```

## 字典树
```cpp
#include <ext/pb_ds/trie_policy.hpp>
using Trie =  __gnu_pbds::trie<string, null_type, trie_string_access_traits<>,
        pat_trie_tag, trie_prefix_search_node_update>;
tr.insert(s);
tr.erase(s);
tr.find(s);
tr.join(b);//将b并入tr
tr.prefix_range(s);//返回一对始末迭代器,表示以s为前缀的所有数据的范围
```


## 可合并堆
```cpp
__gnu_pbds::priority_queue<int>Q1;
__gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> Q2; 
//还有四种分别是binary，binomal，thin，rc_binomal_heap_tag
push(x)  //会返回迭代器
erase(it)//迭代器类型为point_iterator
modify(it, x) //修改对应点的值(均摊复杂度O(1))
join(&other)//合并
split(x, &other) //以某个值为界限拆分
//top(),pop()同std的优先队列
//还有begin(),end(),++it等操作
```

# 随机数
```cpp
#include<random>
mt19937_64 rng(random_device{}());
ll rdi(ll l, ll r) {
    return rng() % (r-l+1) + l;
}
shuffle(p.begin(), p.end(), rng);// 随机打乱一个序列
```

# HashMap
STL unordered_map防被卡
```cpp
#include<chrono>
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        x+=0x9e3779b97f4a7c15;
        x=(x^(x>>30))*0xbf58476d1ce4e5b9;
        x=(x^(x>>27))*0x94d049bb133111eb;
        return x^(x>>31);
    }
    uint64_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM=
            chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x+FIXED_RANDOM);
    }
};// unordered_map<int,int,custom_hash> cnt;
```

手写HashMap
```cpp
template<class KTYPE,class VTYPE>
struct HashMap {
    static constexpr int mod=1<<20;
    int head[mod];
    vector<KTYPE> k;// key
    vector<VTYPE> v;// value
    vector<int> nxt;// edge.next
    vector<int> pos;// updated position
    HashMap() {
        memset(head,-1,sizeof head);
    }
    static int Hash(KTYPE x) {
        return x&(mod-1);
    }
    void clear(){
        for(int p:pos) head[p]=-1;
        k.clear(), v.clear(), nxt.clear(), pos.clear();
    }
    bool count(KTYPE x) {
        int p=Hash(x);
        for(int i=head[p]; ~i ;i=nxt[i])
            if (k[i]==x)
                return true;
        return false;
    }
    VTYPE& operator[](KTYPE x) {
        int p=Hash(x);
        if(head[p]==-1)
            pos.push_back(p);
        for(int i=head[p]; ~i ;i=nxt[i])
            if (k[i]==x)
                return v[i];
        k.push_back(x), v.push_back(0);
        nxt.push_back(head[p]), head[p]=nxt.size()-1; 
        return v.back();
    }
    auto getInfo()const {
        vector<pair<KTYPE,VTYPE>> q;
        for(int p:pos)
            for(int i=head[p]; ~i ;i=nxt[i])
                q.emplace_back(k[i],v[i]);
        return q;
    }
};
```

# Xor Shift  
```cpp
#include<chrono>
using ull=unsigned long long;
const ull mask=
    chrono::steady_clock::now().time_since_epoch().count();
ull shift(ull x) {
    x^=mask;
    x^=x<<13;
    x^=x>>7;
    x^=x<<17;
    x^=mask;
    return x;
}
```

# 程序运行计时
```cpp
clog<<"Time elapsed: "<<1.*clock()/CLOCKS_PER_SEC<<" s.\n";
```

# 手动开栈
```cpp
int size = 512<<20; // 512M
__asm__ ( "movq %0, %%rsp\n"::"r"((char*)malloc(size)+size));
```

# 模拟退火
```cpp
using Arr=array<int,24>;
int n;
Arr a;
double bestAns = 0;// max
Arr bestS;
double calc() {
    int res=0;
    ll sum=0;
    for(int i=0; i<n; ++i) {
        sum += a[i];
        res += sum==0;
    }
    if(res > bestAns) bestAns = res, bestS = a;
    return res;
}
constexpr double mt = 3000, t0 = 1e-3, dt = 0.99;
double rand1() {return (double)rand()/RAND_MAX;}
double rand2() {return 2.*rand()/RAND_MAX - 1;}
int randInt(int l,int r) {return rand()%(r-l+1)+l;}
void annealing() {
    auto curAns = bestAns;
    a = bestS;
    for(double t=mt; t>t0; t*=dt) {
        int i = rand()%n;
        int j = rand()%n;
        if(i==j) continue;
        swap(a[i], a[j]);
        double w = calc();
        double delta = -(w - curAns);// TODO +:越小越好 -:越大越好
        if(delta < 0) {
            curAns = w;
        }
        // else if(!rand()) {// 玄学有效
        else if(exp(-delta/t) > rand1()) {
            curAns = w;
        }else {// 不接受
            swap(a[i], a[j]);
        }
    }
}
// 调用前可以先 calc(一个看起来比较优秀的解) 以加速寻找过程
void start_sa(double maxt) {
    srand((unsigned)clock() * ((unsigned)time(0) + 1));
    int MAXT = maxt * CLOCKS_PER_SEC;
    int clock_st = clock();
    annealing();
    int clock_time = (int)clock() - clock_st;
    int run_times = 1;
    while (clock_time + clock_time / run_times < MAXT) {
        clock_st = clock();
        annealing();
        clock_time += (int)clock() - clock_st;
        run_times++;
    }
}
```

二维平面上寻找一个最优点
```cpp
double bestX, bestY, bestAns = 1e18;
double calc(double x0, double y0) {
    double sum=0;
    for(int i=0; i<n; ++i) {
        double dx=x[i]-x0;
        double dy=y[i]-y0;
        sum += sqrt(dx*dx+dy*dy)*w[i];
    }
    if(sum < bestAns) bestAns=sum, bestX=x0, bestY=y0;
    return sum;
}
constexpr double mt = 10000, t0 = 1e-3, dt = 0.99;
void annealing() {
    double curx=bestX, cury=bestY, curAns=bestAns;
    for(double t=mt; t>t0; t*=dt) {
        double nx = curx + t * rand2();
        double ny = cury + t * rand2();
        double w = calc(nx,ny);
        double delta = (w - curAns);
        if(delta<0 || exp(-delta/t) > rand1())
            curx=nx, cury=ny, curAns=w;
    }
    for (int i=1; i<=1000; ++i) {
        double nx = bestX + t0 * rand2();
        double ny = bestY + t0 * rand2();
        calc(nx, ny);
    }
}
```

# 快读快写
```cpp
// 用快读之后，不能再使用scanf和cin读入
namespace io {
    constexpr int MAXBUF = 1e6;
    char buf[MAXBUF], *pl, *pr;
    #define gc() (pl == pr && (pr = (pl = buf)  \
        + fread(buf, 1, MAXBUF, stdin), pl == pr) ? EOF : *pl++)
    template<typename T>
    void read(T& x) {
        x = 0;
		int neg = 0, c = gc();
        for(; c<'0' or c>'9'; c = gc()) neg |= c == '-';
        for(; c>='0' and c<='9'; c = gc()) x = (x<<3) + (x<<1) + (c^48);
        if(neg) x = -x;
    }
    template<typename T, typename ...Ts>
    void read(T& x, Ts& ...args) {
		read(x);
        read(args...);
    }
    template<typename T>
    void write(T x) {
        if(x<0) putchar('-'), x = -x;
        if(x>9) write(x/10);
        putchar(x%10 + '0');
    }
    template<typename T, typename ...Ts>
    void write(T& x, Ts& ...args) {
		write(x);
		putchar(' ');
		write(args...);
    }
    void ed() { putchar('\n'); }
} using io::read, io::write, io::ed;
```